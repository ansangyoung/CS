# Java의 정석 3rd Edition  
### 남궁 성 지음  
  
  
# Chapter 06 객체지향 프로그래밍1(Object-oriented Programming 1)  
  
## 6.1 객체지향언어  
### 6.1.1 객체지향언어의 역사  
객체지향이론의 기본 개념은 '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.'라는 것이다.  
자바가 1995년에 발표되고 1990년대 말에 인터넷의 발전과 함께 크게 유행하면서 객체지향언어는 이제 프로그래밍언어의 주류로 자리 잡았다.  
  
  
### 6.1.2 객체지향언어  
객체지향언어의 주요특징은 다음과 같다.  
1. 코드의 재사용성이 높다.  
-새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.  
  
2. 코드의 관리가 용이하다.  
-코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.  
  
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.  
-제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며,  
코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.  
  
#### 핵심  
너무 객체지향개념에 얽매여서 고민하기 보다는 일단 프로그램을 기능적으로 완성한 다음,  
어떻게 하면 보다 객체지향적으로 코드를 개선할 수 있을지를 고민하여 점차 개선해나가는 것이 좋다.  
  
  
  
## 6.2 클래스와 객체  
### 6.2.1 클래스와 객체의 정의와 용도  
클래스의 정의: 클래스란 객체를 정의해 놓은 것이다.(객체의 설계도)  
클래스의 용도: 클래스는 객체를 생성하는데 사용된다.  
  
#### 객체  
1. 사전적인 정의: 실제로 존재하는 것.  
2. 객체지향이론에서의 정의: 사물과 같은 유형적인 것 뿐만 아니라, 개념이나 논리와 같은 무형적인 것들도 객체로 간주한다.  
3. 프로그래밍에서의 정의: 클래스에 정의된 내용대로 메모리에 생성된 것.  
  
객체는 변수들의 컬렉션으로 정의할 수있다.  
간단하거나 복잡한 개체(entity)와 개체들에 관련된 연산을 제공하는 메서드들의 모음을 나타내기 때문이다.  
따라서 객체에는 상태와 행위가 있다고 생각하면 이해하기 쉽다.  
(원시타입을 제외하면 자바 언어의 다른 모든 변수들은 참조 타입이다. 이들은 객체라고 더 잘 알려져 있으며, 빈 객체를 의미하는 표현인 null이 존재한다.)  
즉, 변수들이 null로 설정될 수 있으며 메서드 또한 null을 반환할 수 있다. 그러나 null 참조에 대한 메서드를 호출할 수는 없다.  
  
객체에 선언하는 final 키워드는 원시 타입에 선언하는 final 키워드와 동일한 역할을 한다.  
즉, 변수 정의에서 지정된 값처럼 일단 할당이 되고 나면 메모리 위치가 변경되지 않는다.  
단, 객체 참조는 변경할 수 없어도 객체 내부의 값들은 개별 값들이 final이 아니라면 변경할 수 있다.  
  
클래스와 객체의 관계는 "제품의 설계도와 제품"의 관계라고 할 수 있다.  
예를들어 TV설계도는 TV라는 제품을 정의한 것이며, TV를 만드는데 사용된다.  
  
JDK(Java Develpment Kit)에서는 프로그래밍을 위해 많은 수의 유용한 클래스(Java API)를 기본적으로 제공하고 있으며,  
우리는 이 클래스들을 이용해서 원하는 기능의 프로그램을 보다 쉽게 작성할 수 있다.  
  
  
#### JDK(Java Development Kit)  
자바 응용 개발 환경으로, 개발에 필요한 도구 포함한다.(컴파일러, JRE, 클래스 라이브러리, 샘플 등)  
설치과정은 http://java.sun.com에서 Java SE를 다운로드하여 환경변수를 설정 후, DOS 창에서 JDK를 확인한다.  
  
  
### 6.2.2 객체와 인스턴스  
클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며,  
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.  
결국 인스턴스는 객체와 같은 의미이지만,  
객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있으며,  
인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 갖고 있다.  
(즉, 비슷한 성질을 가진 여러 개의 객체를 만들기 위해서, 클래스의 생성자 함수를 통해 생성된 객체)  
(객체 ⊃ 인스턴스)  
  
문맥에 따라 구별하여 사용하는 것이 좋다.  
1. 책상은 인스턴스다. VS 책상은 객체다.  
2. 책상은 책상 클래스의 객체이다. VS 책상은 책상 클래스의 인스턴스이다.  
  
  
### 6.2.3 객체의 구성요소 - 속성과 기능  
객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있다.  
속성과 기능은 같은 뜻의 여러 가지 용어가 있는데, 이 책에서는 속성은 멤버변수로, 기능은 메서드로 주로 사용하여 표현한다.  
1. 속성(property): 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)  
2. 기능(function): 메서드(method), 함수(function), 행위(behavior)  
  
TV를 예로 들면, TV의 속성으로는 전원상태, 크기, 길이, 높이, 색상, 볼륨, 채널과 같은 것들이 있으며,  
기능으로는 켜기, 끄기, 볼륨 높이기, 채널 변경하기 등이 있다.  
객체지향 프로그래밍에서는 속성과 기능을 각각 변수와 메서드로 표현한다.  
채널 -> ``int channel;``  
채널 높이기 -> ``channelUp() {...}``  
전원상태 -> ``boolean power;``  
전원 변경 -> ``void power() { power = !power; }``
- (생각해보기) if문을 사용한다면?  
```  
if(power) {  
    power = false;  
} else {  
    power = true;  
}  
```  
  
  
### 6.2.4 인스턴스의 생성과 사용  
클래스로부터 인스턴스를 생성하는 방법은 여러 가지가 있다.  
```  
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언.  
Tv t; // Tv클래스 타입의 참조변수 t를 선언. 메모리에 참조변수 t를 위한 공간이 마련된다. 아직 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 할 수 없다.  
  
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장.  
t = new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장. 
              // 1. 연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성된다.   
              // 2. 이 때 멤버변수는 각 자료형에 해당하는 기본값으로 초기화된다. String -> null, boolean -> false, int -> 0  
              // 3. 대입연산자에 의해서 생성된 객체의 주소값이 참조변수 t에 저장된다.(참조변수 t가 Tv인스턴스를 '가리키고 있다' 또는 '참조하고 있다'라고 한다.)  
```  
  
인스턴스와 참조변수의 관계는 마치 우리가 일상생활에서 사용하는 "TV와 TV리모콘"의 관계와 같다.  
TV리모콘(참조변수)을 사용하여 TV(인스턴스)를 다루기 때문이다.  
즉, TV인스턴스를 사용하려면, Tv클래스 타입의 참조변수가 필요한 것이다.  
(인스턴스는 참조변수를 통해서만 다룰 수 있으며, (기본적으로는)참조변수의 타입은 인스턴스의 타입과 일치해야 한다.)  
  
#### 참고  
자신을 참고하고 있는 참조변수가 하나도 없는 인스턴스는 더 이상 사용되어질 수 없으므로,  
가비지컬렉터에 의해 자동적으로 메모리에서 제거된다.  
  
  
### 6.2.5 객체 배열  
객체 역시 배열로 다루는 것이 가능하며, 이를 '객체 배열'이라고 한다.  
객체 배열 안에 객체가 저장되는 것이 아니라, 객체의 주소가 저장된다.  
(참조변수들을 하나로 묶은 참조변수 배열인 것이다.)  
```  
Tv tv1, tv2, tv3;  
-> Tv[] tvArr = new Tv[3];  // 각 요소는 참조변수의 기본값인 null로 자동 초기화 된다.  
-> Tv[] tvArr = { new Tv(), new Tv(), new Tv() };  // 초기화블럭 사용시  
```  
  
다형성을 배우고 나면, 하나의 배열로 여러 종류의 객체를 다룰 수 있게 된다.  
  
  
### 6.2.6 클래스의 또 다른 정의  
프로그래밍 관점에서의 클래스는 서로 연관된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이다.  
  
#### 사용자 정의 타입  
프로그래머가 서로 연관된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것.  
(클래스가 곧 사용자 정의 타입이다.)  
기본형의 개수가 8개이지만, 참조형의 개수가 정해져 있지 않은 이유는 이처럼 프로그래머가 새로운 타입을 추가할 수 있기 때문이다.  
  
  
  
## 6.3 변수와 메서드  
### 6.3.1 선언위치에 따른 변수의 종류  
변수는 클래스변수, 인스턴스변수, 지역변수 모두 세 종류가 있다.  
변수의 종류를 결정짓는 중요한 요소는 '변수의 선언된 위치'이다.  
(선언 위치가 클래스 영역이면 멤버변수, 클래스 영역 이외면 지역변수이다.)  
  
즉, 멤버변수를 제외한 나머지 변수들은 모두 지역변수이며, 멤버변수 중 static이 붙은 것은 클래스변수, 붙지 않은 것이 인스턴스변수이다.  
(멤버변수는 인스턴스변수와 static 변수를 모두 통칭하는 말이다.)  
```  
class Variables {  
    int iv; // 인스턴스 변수  
    static int cv; // 클래스변수  
    
    void method() { // 메서드 영역  
        int lv = 0; // 지역변수  
    }  
}  
```  
  
#### 생성시기  
1. 클래스변수: 클래스가 메모리에 올라갈 때  
(참조변수의 선언이나 객체의 생성과 같이 클래스의 정보가 필요할 때, 클래스는 메모리에 로딩된다.)  
2. 인스턴스변수: 인스턴스가 생성되었을 때  
3. 지역변수: 변수 선언문이 수행되었을 때  
  
#### 클래스변수 vs 인스턴스변수  
인스턴스는 독릭적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.  
인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스변수로 선언한다.  
이와 달리, 클래스변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다.  
한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스변수로 선언해야 한다.  
또한, 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있으며, 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때 까지 유지된다.  


#### static  
static은 원리를 알고 잘 사용하면 시스템의 성능을 향상시킬 수 있다.  
1. static으로 선언한 변수는 객체의 변수가 되는 것이 아니라 클래스변수가 된다.  
2. 클래스변수를 포함한 클래스의 인스턴스를 여러 개 생성하더라도, 모든 객체가 클래스 변수에 대해서는 동일한 주소의 값을 참조한다.  
-> 다른 JVM 에서는 static이라고 선언해도 다른 주소나 다른 값을 참조하지만, 하나의 JVM이나 WAS 인스턴스에서는 같은 주소에 존재하는 값을 참조한다.  
  
3. GC의 대상이 되지 않는다. 이는 곧 OutOfMemoryError 를 발생시킬 수 있으며, 이 경우 해당 인스턴스는 더이상 서비스할 수 없어서 시스템을 재시작해야 한다.  
-> 더 이상 사용 가능한 메모리가 없어지는 현상을 메모리릭이라고 하며, 원인은 메모리의 현재 상태를 파일로 남기는 HeapDump라는 파일을 통해서 확인 가능하다. JDK/bin 디렉토리에 있는 jmap이라는 파일을 사용하여 덤프를 남길 수 있으며, 남긴 덤프는 eclipse 프로젝트에서 제공하는 MAT와 같은 툴을 통해서 분석하면 된다.  
  
4. static을 잘못 사용하는 예로  다음을 기억해 두자.  
``private static boolean successFlg; // 응시자의 합격 여부 ``  
수십 명이 동시에 자신의 정보를 호출한다면, 다른 사용자의 요청에 의해 다른 결과를 받게 된다.  
  
  
### 6.3.2 클래스변수와 인스턴스변수  
-사용 예시로 생략  
  
  
### 6.3.3 메서드  
특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것으로, 기본적으로 수학의 함수와 유사하다.  
메서드가 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐,  
이 메서드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 전혀 몰라도 된다.  
(입력과 출력만 알면 된다.)  
    
#### 메서드를 사용하는 이유  
1. 높은 재사용성  
2. 중복된 코드의 제거  
3. 프로그램의 구조화  
-main메서드 안에 모든 문장을 넣는 식으로 프로그램을 작성하는 것보다는,  
문장들을 작업단위로 나눠서 여러 개의 메서드에 담아 프로그램의 구조를 단순화시키는 것이 좋다.  
  
  
### 6.3.4 메서드의 선언과 구현  
메서드의 이름은 이름만으로도 메서드의 기능을 쉽게 알 수 있도록 함축적이면서도 의미있는 이름을 짓도록 노력해야 한다.  
  
  
### 6.3.5 메서드의 호출  
메서드를 호출할 때 괄호()안에 지정해준 값들을 '인자(argument)' 또는 '인수'라고 한다.  
인자는 메서드가 호출되면서 매개변수에 대응되므로, 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.  
  
#### 인자(인수) VS 매개변수  
-호출할 때 지정해준 값 VS 메서드 선언부  
  
같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만,  
static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.    
(유틸리티 함수를 만드는데 유용하게 사용된다.)  
```  
class Test {  
    Test () {}  
    static void m1 () {}  
    void m2 () {}  
}  
Test.m1() // O  
Test.m2() // X  

Test test = new Test();  
test.m1() // X  
test.m2() // O  
출처: https://mygumi.tistory.com/253 [마이구미의 HelloWorld]  
```  
  
  
### 6.3.6 return문  
원래는 모든 메서드에는 적어도 하나의 return 문이 있어야 한다.  
반환타입이 void인 경우, return문 없이도 아무런 문제가 없었던 이유는 컴파일러가 메서드의 마지막에 'return;'을 자동적으로 추가해주었기 때문이다.  
```  
(생각해보기)  
int add(int x, int y) {  
    int result = x + y;  
    return result;  
}  

int add(int x, int y) {  
    return x + y;  
}  
```  
  
  
#### 매개변수의 유효성 검사  
매개변수의 값을 보정하는 것이 불가능하다면, return 문을 통해 작업을 중단하고, 호출한 메서드로 되돌아 가야 한다.  
  
  
### 6.3.7 JVM의 메모리구조  
응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.  
3가지 주요 영역(method area, call stack, heap)이 있다.  
  
1. 메서드 영역(method area)  
-프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(``*.class``)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다.  
이 때, 그 클래스의 클래스변수(``class variable, ex)static int cv;``)도 이 영역에 함께 생성된다.  
즉, static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.  
  
2. 호출 스택(call stack)  
-지역변수   
  
3. 힙(heap)  
-인스턴스가 생성되는 공간이다. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.  
(즉, 인스턴스변수(instance variable)들이 생성되는 공간이다.)  
즉, 프로그래머가 관리하는 메모리 영역이으로 new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.  
  
  
#### 메모리 상수풀 영역  
힙영역에 생성되어 자바 프로세스 종료까지 계속 유지되는 메모리영역.  
기본적으로 JVM에서 관리하며 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고  
없으면 상수풀에 추가한 이후 그 주소값을 리턴한다.  
그로 인해 메모리 절약 효과가 있다.  
  

### 호출 스택(call stack)  
호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다.  
메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며,  
이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다.  
메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.  
즉, 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리다.  
  
#### 호출스택의 특징  
1. 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.  
2. 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.  
3. 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.  
4. 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.  
  
  
### 6.3.8 기본형 매개변수와 참조형 매개변수  
자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다.  
매개변수의 타입이 기본형일 때는 기본형 값이 복사되지만, 참조형이면 인스턴스의 주소가 복사된다.  
즉, 기본형 매개변수는 변수의 값을 읽기만 할 수 있고, 참조형 매개변수는 변수의 값을 읽고 변경할 수 있다.  
  
  
### 6.3.9 참조형 반환타입  
반환타입이 '참조형'이라는 것은 메서드가 '객체의 주소'를 반환한다는 것을 의미한다.  
즉, 모든 참조형 타입의 값은 객체의 주소이므로, 그저 정수값이 반환되는 것 일 뿐 특별한 것이 없다.  
  
#### 가변인자(varargs)  
기존에는 메서드의 매개변수가 고정적이었으나 JDK 1.5부터는 동적으로 지정해 줄 수 있게 되었다.  
이 기능을 가변인자라고 한다. 가능하면 가변인자를 사용한 메서드는 오버로드하지 않는 것이 좋다.  
  
  
### 6.3.10 재귀호출(recursive call)  
반복문 대신 재귀호출을 사용하는 이유는 재귀호출이 주는 논리적 간결함 때문이다.  
아무리 효율적이라도 알아보기 힘들게 작성하는 것보다는,  
다소 비효율적이라도 알아보기 쉽게 작성하는 것이 논리적 오류가 발생할 확률도 줄어들고, 나중에 수정하기도 좋다.  
  
스택오버플로우와 같은 에러가 발생할 수 있다.  
  
  
### 6.3.11 클래스 메서드(static메서드)와 인스턴스 메서드  
(멤버변수는 인스턴스변수와 static 변수를 모두 통칭하는 말이다.)  
1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.  
2. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.  
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.  
-인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다.  
 인스턴스 변수가 존재한다는 것은 static변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.  
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.  
-메서드 호출시간이 짧아지므로 성능이 향상된다.  
  
  
### 6.3.12 클래스 멤버와 인스턴스 멤버간의 참조와 호출  
같은 클래스에 속한 멤버들 간에도 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다.  
단, 클래스멤버가 인스턴스 멤버들 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.  
(인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.)  
```  
class TestClass {  
    void instanceMethod() {} // 인스턴스메서드  
    static void staticMethod() {} // static메서드  
    
    void instanceMethod2() {  
        instanceMethod();  
        staticMethod();  
    }  
    
    void staticMethod2() {  
        instanceMethod();	// 에러  
        staticMethod();  
    }  
}  
```  
  
실제로는 같은 클래스 내에서 클래스멤버가 인스턴스멤버를 참조 또는 호출해야하는 경우는 드물다.  
만일 그런 경우가 발생한다면, 인스턴스메서드로 작성해야할 메서드를 클래스메서드로 한 것은 아닌지 한 번 더 생각해봐야 한다.  
  
  
#### 사용 자제해야할 메서드  
1. ``static void gc()``  
자바에서 사용하는 메모리를 명시적으로 해제하도록 GC를 수행하는 메서드다.  
2. ``System.exit(int status)``  
현재 수행중인 JVM을 종료하는 메서드로, 매개변수인 int 값은 정상종료인지 아닌지를 나타내는 상태코드이다. 0은 정상종료를, 그렇지 않은 숫자는 비정상 종료를 의미한다.  
3. ``static void runFinalization()``  
Object 객체에 있는 finalize()라는 메서드는 자동으로 호출되는데, 가비지 콜렉터가 알아서 해당 객체를 더 이상 참조할 필요가 없을 때 호출한다. 이 메서드를 호출하면 참조 해제 작업을 기자리는 모든 객체의 finalize() 메서드를 수동으로 수행해야 한다.  
  
  
## 6.5 생성자(Constructor)  
``Card c = new Card();``  
1. 연산자 new에 의해 메모리(heap)에 card 클래스의 인스턴스가 생성된다.  
2. 그 다음 생성자 card()가 호출되어 수행된다.  
3. 결과로 생성된 card 인스턴스의 주소가 반환되어 참조변수 c에 저장된다.  
  
  
  
# Chapter 07 객체지향 프로그래밍2(Object-oriented Programming 2)  
## 7.1 상속 (inheritance)  
### 7.1.1 상속의 정의와 장점  
1. 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.  
2. 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.  
(접근 제어자가 private 또는 default인 멤버들은 상속되지 않는다기보다는  
상속은 받지만 자손 클래스로부터의 접근이 제한되는 것이다.)  
  
자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.  
  
  
### 7.1.4 단일 상속(single inheritance)  
클래스를 이용하여 다중 상속을 할 경우 메서드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어서  
자바에서는 클래스를 통한 다중 상속은 지원하지 않는다.  
(클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다는 점에서  
단일상속이 다중상속보다 유리하다.)  
  
  
### 상속 VS 다형성  
상속과 다형성은 객체 지향 개발의 두 가지 핵심 개념이다.  
상속은 부모클래스에서 클래스의 행동과 정의를 가져다 사용할 수 있게 해준다.  
새로운 클래스를 정의할 때 이전에 정의된 클래스에서 정의와 상태를 상속할 수 있고 새로운 행동을 추가하거나 새로운 타입에 대한 행동을 오버라이드할 수 있다.  
예들 들어, Square 클래스는 Rectangle을 상속한다.  
(정사각형 역시 사각형 is-a rectangle이라고 부를 수 있다.)  
  
다형성은 행동의 특정 타입에 대한 정의를 만들 수 있게 하고, 행동을 구현하는 수많은 다른 클래스들을 갖게 한다.  
부모 클래스를 요청했을 때 하위 클래스를 대신 사용하는 것으로도 생각할 수 있다.  
이때 하위 클래스의 행위는 유지되겠지만, 다형성을 사용하는 사용자가 하위클래스의 행위를 이해하지 못할 수 있다.  
따라서, Square 클래스에 구체적으로 정의되어 있는 메서드는 Rectangle 클래스에서는 사용할 수 없다.  
  
  
## 7.3 package와 import  
### 7.3.5 static import문  
import문을 사용하면 클래스의 패키지명을 생략할 수 있는 것과 같이  
static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다.  
  
특정 클래스의 static멤버를 자주 사용할 때 편리하며, 코드도 간결해진다.  
```  
import static java.lang.Math.random;  
import static java.lang.System.out;  
  
...  
//System.out.println(Math.random());  
out.println(random());  
...  
```  
  
  
## 7.4 제어자(modifier)  
### 7.4.1 제어자란?  
클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.  
제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.  
1. 접근제어자: public, protected, default, private  
2. 그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp  
  
  
#### native  
자바에서 다른 언어를 사용할 수 있게 만들어주는 키워드.  
ex) JNI를 사용할 때, native 키워드가 사용된다.  
  
  
#### JNI(JAVA Native Interface)  
자바로 만들어진 프로그램에서 특정 플랫폼에서만 실행되는 코드(Native Code)에 접근하기 위한 API이다.  
ex) c <-> java  
```  
톰캣 서버 DataSource 설정하는 context.xml 예시  
<?xml version="1.0" encoding="UTF-8"?>  
<Context path="/">  
    <WatchedResource>WEB-INF/web.xml</WatchedResource>  
    <Resource name="jdbc/knou" auth="Container" type="javax.sql.DataSource"  
              maxActive="10" maxIdle="3" maxWait="10000"  
              username="butterfield" password="1234"  
              driverClassName="com.mysql.cj.jdbc.Driver"  
              url="jdbc:mysql://localhost:3307/knou"  
              closeMethod="close" />  
</Context>  
```  
  
  
#### transient  
Serialize(직렬화)하는 과정에서 제외하고 싶은 경우 선언하는 키워드.  
직렬화: 자바 시스템 내부에서 사용되는 Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte형태로 데이터를 변환하는 기술.  
  
  
#### volatile  
thread에서 사용되는 것인데, cpu cache와 메인메모리에서의 read & write상에서의 불일치를 해결하기 위해 사용되는 키워드이다.  
(성능에 영향을 줄 수 있는 키워드라서 제한적으로 꼭 필요한 상황에만 써야 한다.)  
  
  
#### strictfp  
자바와 타 플랫폼간의 부동소수점의 정밀도를 맞춰주기 위한 키워드이다.  
  
  
### 7.4.5 접근 제어자(access modifier)  
제어자들 간의 순서는 관계없지만, 주로 접근제어자를 제일 왼쪽에 놓는 경향이 있다.  
  
#### 생성자의 접근 제어자  
생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.  
생성자의 접근 제어자를  private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로, 인스턴스를 생성할 수 없게 된다.  
(그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.)  
```  
class Singleton {  
    private Singleton() {  
        ...  
    }  
    ...  
}  
```  
  
대신에 인스턴스를 생성해서 반환해주는  public 메서드를 제공함으로써, 외부에서 이 클래스의 인스턴스를 사용하도록 할 수 있다.  
이 메서드는 public인 동시에 static이어야 한다.  
```  
class Singleton {  
    // getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로, static이어야 한다.  
    private static Singleton s = new Singleton();  
      
    private Singleton() {  
        ...  
    }  
    
    // 인스턴스를 생성하지 않고도 호출할 수 있어야 하므로, static이어야 한다.  
    public static Singleton getInstance() {  
        return s;  
    }  
    ...  
}  
```  
이처럼 생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 public메서드를 통해 인스턴스에 접근하게 함으로써,  
사용할 수 있는 인스턴스의 개수를 제한할 수 있다.  
  
  
### 7.4.6 제어자(modifier)의 조합  
제어자를 조합해서 사용할 때 주의해야 할 사항에 대해 정리  
1. 메서드에 static과 abstract를 함께 사용할 수 없다.  
-static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.  
  
2. 클래스에 abstract와 final을 동시에 사용할 수 없다.  
-클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고,  
abstract는 상속을 통해서 완성되어야 한다는 의미이므로, 서로 모순되기 때문이다.  
  
3. abstract메서드의 접근 제어자가 private일 수 없다.  
-abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다.  
  
4. 메서드에 private과 final을 같이 사용하 필요는 없다.  
-접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.  
  
  
  
## 7.5 다형성(polymorphism)  
### 7.5.1 다형성이란?  
여러 가지 형태를 가질 수 있는 능력을 의미한다.  
자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.  
이를 좀 더 구체적으로 말하자면, 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다.  
  
```  
//class Tv  
//class CaptionTv extends Tv  
  
CaptionTv c = new CaptionTv();  
Tv t = new CaptionTv();  
```  
(Tv타입의 참조변수로는 CaptionTv인스턴스 중에서 Tv클래스의 멤버들(상속받은 멤버 포함)만 사용할 수 있다.)  
  
  
  
## 7.6 추상클래스(abstract class)  
### 7.6.1 추상클래스란?  
추상메서드를 하나 이상 가진 클래스.  
클래스 구현부 내부에 추상 메서드가 하나 이상 포함되고, abstract로 정의된 경우를 말한다.  
추상 메서드를 포함하고 있다는 점을 제외하면, 일반 클래스와 모든점이 같다.  
(생성자와 필드, 일반 메서드도 포함할 수 있다.)  

주의  
자신의 생성자로 인스턴스 생성 불가능하다.  
그래서 먼저 상속을 통해 자식 클래스를 만들고, 만들 자식 클래스에서 추상 클래스의 모든 추상 메서드를 오버라이딩하고 나서야  
비로소 자식클래스의 인스턴스를 생성할 수 있게 된다.  

목적  
즉, 하위 클래스를 제어하기 위해 사용한다.  
```
abstract class Animal {  
    abstract void cry();  
}  

class Cat extends Animal {  
    void cry() {  
        System.out.println("냐옹냐옹!");  
    }  
}  

class Dog extends Animal {  
    void cry() {  
        System.out.println("멍멍!");  
    }  
}  

public class Polymorphism02 {  
    public static void main(String[] args) {  
        // Animal a = new Animal(); // 추상 클래스는 인스턴스를 생성할 수 없음.  
        Cat c = new Cat();  
        Dog d = new Dog();  
        c.cry(); // 냐옹냐옹!  
        d.cry(); // 멍멍!  
    }  
}  
```


### 7.6.2 추상 메서드(abstract method)  
선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다.  
즉, 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메서드이다.  
목적은 추상메서드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상메서드를 구현하도록 하기 위함이다.  
(만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.)  



## 7.7 인터페이스(interface)  
### 7.7.1 인터페이스란?  
인터페이스는 하위 클래스에 특정한 메서드가 반드시 존재하도록 강제한다.  
또한 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록 한다.  
실질적으로는 협업자 상호간에 동일한 메서드를 만들도록 규약을 만드는데 이용할 수 있다.  

특징으로 다중 상속이 가능하다.  
멤버는 반드시 public이며, 오직 추상메서드와 상수만을 멤버로 갖는다.  
일종의 추상 클래스이다.  
추상 클래스와 다르게 하나의 클래스가 여러 개의 인터페이스를 구현 할 수 있지만,  
구체적인 로직이나 상태를 가지고 있을 수 없다.  
```  
접근제어자 interface 인터페이스이름 {  
    public static final 타입 상수이름 = 값;  
    ...  
    public abstract 메서드이름(매개변수목록);  
    ...  
}  
```  


### Interface vs Abstract  
공통점  
1. new 연산자로 인스턴스 생성 불가능.  
2. 프로토타입만 있는 메서드를 갖는다.  
3. 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.  
(다른 클래스를 작성하는데 도움 줄 목적으로 작성된다.)  
4. 가지고 있는 추상메서드를 구현하도록 강제한다.  
  
차이점  
1. 클래스를 설계도에 비유한다면, 추상클래스를 부분적으로만 완성된 '미완성 설계도'이고,  
인터페이스는 구현된 것은 아무 것도 없고 밑그림만 그려져 있는 '기본 설계도'라 할 수 있다.  
2. 추상클래스는 일반 메서드를 사용할 수 있지만, 인터페이스는 메서드 선언만 가능하다.  
(인터페이스는 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.)  
3. 추상클래스는 어느정도 틀을 갖춘 상태에서 진행이 필요하거나, 관련성이 높은 클래스 간에 코드를 공유하고 싶은 경우 사용할 수 있다.  
4. 인터페이스는 다른 클래스를 작성하는데 도움을 줄 목적으로 작성된다. 다중상속을 허용하고 싶은 경우에 사용한다.  
  
  
## 7.8 내부 클래스(inner class)  
클래스 내에 선언된다는 점을 제외하고는 일반적인 클래스와 다르지 않다.  

### 7.8.1 내부 클래스란?  
클래스 내에 선언된 클래스이다.  
클래스에 다른 클래스를 선언하는 이유는 두 클래스가 긴밀한 관계에 있기 때문이다.  

장점  
-내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.  
-외부에 불필요한 클래스르 감춤으로써 코드의 복잡성을 줄일 수 있다(캡슐화).  


### 7.8.5 익명 클래스(anonymous class)  
익명 클래스는 특이하게도 다른 내부 클래스들과는 달리 이름이 없다.  
클래스의 선언과 객체의 생성을 동시에 하기 때문에  
단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.  
```  
    new 조상클래스이름() {  
        // 멤버 선언  
    }  
    
    // 또는  
    new 구현인터페이스이름() {  
        // 멤버 선언  
    }  
```  
  
  
이름이 없기 때문에 생성자도 가질 수 없으며,  
조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기 때문에  
하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다.  
즉, 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.  

예제7-36/ch7/InnerEx6.java를 컴파일 하면 4개의 클래스 파일이 생성된다.  
``// C:\gitWorkspace\privateCS2\bin\ch7``  
익명 클래스는 이름이 없기 때문에 ``외부 클래스명$숫자.class``의 형식으로 클래스 파일명이 결정된다.  

독립된 클래스를 익명클래스를 이용하여 변경하면 보다 쉽게 코드를 작성할 수 있다.  
-> 형상관리 솔루션에서는?  
  
  
  
# Chapter 08 예외처리(Exception Handling)  
## 8.1 예외처리(exception handling)  
### 8.1.1 프로그램 오류  
#### 에러 종류 3가지  
컴파일 에러: 컴파일 시에 발생하는 에러  
런타임 에러: 실행 시에 발생하는 에러  
논리적 에러: 실행은 되지만, 의도와 다르게 동작하는 것  
  
#### 에러 VS 예외  
에러와 예외 모두 실행 시(runtime) 발생하는 오류이다.  
에러: 프로그램 코드에 의해서 수습될 수 없는 심각한 오류  
-메모리 부족, 스택오버플로우  
예외: 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류  
  
  
### 8.1.2 예외 클래스의 계층구조  
Exception과 Error클래스 역시 Object클래스의 자손들이다.  
모든 예외의 최고 조상은 Exception클래스이다.  
```  
Exception  
-IOException  
-ClassNotFoundException  
-...  
-RuntimeException  
    -ArithmeticException  
    -ClassCastException  
    -NullPointerException  
    -...  
    -IndexOutOfBoundsException  
```  
즉, Exception클래스와 그 자손들로 나눌 수 있고, RuntimeException클래스와 그 자손들로 나눌 수 있다.  
  
Excetpion클래스들: 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외  
-존재하지 않는 파일의 이름을 입력했다던가, 실수로 클래스의 이름을 잘못 적었다던가, 입력한 데이터 형식이 잘못된 경우에 발생.  
RuntimeException클래스들: 프로그래머의 실수로 발생하는 예외  
-배열의 범위를 벗어난다던가, 값이 null인 참조변수의 멤버를 호출하려 했다던가, 클래스간의 형변환을 잘못했다던가, 정수를 0으로 나누려고 하는 경우에 발생.  
  
  
### 8.1.3 예외처리하기 - try-catch문  
#### 예외처리(exception handling)  
정의: 프로그램 실행 시 발생할 수 있는 예외에 대비한 코드를 작성하는 것.  
목적: 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것.
  
정수를 0으로 나누는 경우, ArithmeticException이 발생한다.  
실수를 0으로 나누는 것은 금지되어있지 않으며, 예외가 발생하지 않는다.  
  
  
### 8.1.4 try-catch문에서의 흐름  
생략.  
  
  
### 8.1.5 예외의 발생과 catch블럭  
catch블럭은 괄호()와 블럭{} 두 부분으로 나눠져 있는데, 괄호() 내에는 처리하고자 하는 예외와 같은 타입의 참조변수 하나를 선언해야 한다.  
  
예외가 발생하면, 발생한 예외에 해당하는 클래스의 인스턴스가 만들어 진다.  
  
첫번째 catch블럭부터 차례로 내려가면서 catch블럭의 괄호()내에 선언된 참조변수의 종류와  
생성된 예외클래스의 인스턴스에 instanceof연산자를 이용해서 검사하게 되는데,  
검사결과가 true인 catch블럭을 만날 때까지 검사는 계속된다.  
  
printStackTrace(): 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.  
-printStackTrace(PrintStream s) 또는 printStackTrace(PrintWriter s)를 사용하면 발생한 예외에 대한 정보를 파일에 저장할 수도 있다.  
getMessage(): 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.  
```  
} catch (ArithmeticException ae) {  
    ae.printStackTrace();  
    System.out.println("예외메시지 : " + ae.getMessage());  
}  
  
output example  
java.lang.ArithmeticException: / by zero  
    at ExceptionEx8.main(ExcpetionEx8.java:7)  
예외메시지 : / by zero  
```  
  
  
### 8.1.6 예외 발생시키기  
키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다.  
1. 먼저, 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든다.  
``Exception e = new Exception("고의로 발생시켰음");``  
2. 키워드 throw를 이용해서 예외를 발생시킨다.  
``throw e``  
  
컴파일러가 예외처리를 확인하지 않는 RuntimeException클래스들은 'unchecked예외'라고 부르고,  
예외처리를 확인하는 Exception클래스들은 'checked예외'라고 부른다.  
  
  
### 8.1.7 메서드에 예외 선언하기  
예외를 메서드에서 선언하는 방법이 있다.  
```  
void method() throws Exception1, Exception2, ... ExceptionN {  
    // 메서드의 내용  
}  
```  
예외를 메서드의 throws에 명시하는 것은 예외를 처리하는 것이 아니라, 자신을 호출한 메서드에게 예외를 전달하여 예외처리를 떠맡기는 것이다.  
  
  
### 8.1.8 finally블럭  
try블럭에서 return문이 실행되는 경우에도 finally블럭의 문장들이 먼저 실행된 후에, 현재 실행 중인 메서드를 종료한다.  
이와 마찬가지로 catch블럭의 문장 수행 중에 return문을 만나도 finally블럭의 문장들은 수행된다.  
  
  
### 8.1.9 자동 자원 반환 - try-with-resources문  
try-with-resources문의 괄호()안에 객체를 생성하는 문장을 넣으면  
이 객체는 따로 close()를 호출하지 않아도 try 블럭을 벗어나는 순간 자동적으로 close()가 호출된다.  
```  
// 괄호() 안에 두 문장 이상 넣을 경우 ';'로 구분한다.  
try(FileInputStream fis = new FileInputStream("socre.dat");  
    DataInputStream dis = new DataInputStream("fis)) {  
```  
  
이처럼 try-with-resources문에 의해 자동으로 객체의 close()가 호출될 수 있으려면,  
클래스가 AutoCloseable이라는 인터페이스를 구현한 것이어야만 한다.  
```  
public interface AutoCloseable {  
    void close() throws Exception;  
}  
```  
  
  
### 8.1.10 사용자정의 예외 만들기  
가능하면 새로운 예외 클래스를 만들기보다는 기존의 예외클래스를 활용하는 것이 좋다.  
```  
class MyException extends Exception {  
    // 문자열을 매개변수로 받는 생성자  
    MyException(String msg) {  
        // 조상인 exception클래스의 생성자를 호출한다.  
        super(msg);  
    }  
}  
```  
  
요즘은 예외처리를 선택적으로 할 수 있도록 RuntimeException을 상속받아서 작성하는 쪽으로 바뀌어가고 있다.  
  
  
### 8.1.11 예외 되던지기(exception re-throwing)  
단 하나의 예외에 대해서도 예외가 발생한 메서드와 호출한 메서드, 양쪽에서 처리하도록 할 수 있다.  
이것은 예외를 처리한 후에 인위적으로 다시 발생시키는 방법을 통해서 가능한데, 이것을 `예외 되던지기`라고 한다.  
```  
static void method1() throws Exception {  
    try {  
    } catch (Exception e) {  
        throw e; // 다시 예외를 발생시킨다.  
    }  
}  
```  
  
finally블럭 내에도 return문을 사용할 수 있으며, try블럭이나 catch블럭의 return문 다음에 수행된다.  
(최종적으로 finally블럭 내의 return문의 값이 반환된다.)  
  
  
### 8.1.12 연결된 예외(chained exception)  
한 예외가 다른 예외를 발생시킬 수도 있다.  
예를 들어 예외 A가 예외 B를 발생시켰다면, A를 B의 원인예외(cause exception)이라고 한다.  
```  
try {  
    // SpaceException 발생  
} catch (SpaceException e) {  
    InstallException ie = new InstallException("설치중 예외 발생"); // 예외 생성  
    ie.initCause(e); // InstallException의 원인 예외를 SpaceException으로 지정  
    throw ie; //InstallException을 발생시킨다.  
}  
```  
  
원인 예외로 등록해서 다시 예외를 발생시키는 이유는  
여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위해서이다.  
또 다른 이유는 checked예외를 unchecked예외로 바꿀 수 있도록 하기 위해서이다.  
  
  
  
# Chapter 10 날짜와 시간 & 형식화 date, time and formatting  
## 10.2 형식화 클래스  
형식화 클래스는 java.text패키지에 포함되어 있으며 숫자, 날짜, 텍스트 데이터를 일정한 형식에 맞게 표현할 수 있는 방법을 객체지향적으로 설계하여 표준화하였다.  
  
  
  
# Chapter 11 컬렉션 프레임웍 Collections Framework  
## 11.1 컬렉션 프레임웍(Collections Framework)  
### 컬렉션 프레임웍  
데이터 군을 저장하는 클래스들을 표준화한 설계  
데이터 군을 다루고 표현하기 위한 단일화된 구조  
  
### 컬렉션  
다수의 데이터, 즉 데이터 그룹  
  
### 프레임웍  
표준화된 프로그래밍 방식  
  
  
  
### 11.1.1 컬렉션 프레임웍의 핵심 인터페이스  
컬렉션 프레임웍에서는 컬렉션데이터 그룹을 크게 3가지 타입이 존재한다고 인식하고 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이스를 정의(List, Set, Map)  
인터페이스 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의  
  
  
  
### 11.1.14 컬렉션 클래스 정리 & 요약  
1. ArrayList  
배열기반  
데이터의 추가와 삭제에 불리  
순차적인 추가와 삭제는 제일 빠름  
임의의 요소에 대한 접근성이 뛰어남  
  
2. LinkedList  
연결기반  
데이터의 추가와 삭제에 유리  
임의의 요소에 대한 접근성이 좋지 않다  
  
3. HashMap  
배열과 연결이 결합된 형태  
추가, 삭제, 검색, 접근성이 모두 뛰어남  
검색에는 최고 성능  
  
4. TreeMap  
연결기반  
정렬과 검색(특히 범위검색)에 적합  
검색성능은 HashMap보다 떨어짐  
  
5. Stack  
Vector를 상속받아 구현  
  
6. Queue  
LinkedList가 Queue인터페이스를 구현  
  
7. Properties  
Hashtable을 상속받아 구현  
  
8. HashSet  
HashMap을 이용해서 구현  
  
9. TreeSet  
TreeMap을 이용해서 구현  
  
10. LinkedHashMap, LinkedHashSet  
HashMap과 HashSet에 저장순서유지기능을 추가  
  
  
  
# Chapter 12 지네릭스, 열거형, 애너테이션  
## 12.1 지네릭스(Generics)  
### 12.1.1 지네릭스란?  
지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능이다.  
간단히 얘기하면 다룰 객체의 타입을 미리 명시해줌으로써 번거로운 형변환을 줄여준다.  
  
  
  
## 12.2 열거형(enums)  
### 12.2.1 열거형이란?  
열거형은 서로 관련된 상수를 편리하게 선언하기 위한 것으로 여러 상수를 정의할 때 사용하면 유용하다.  
```  
class Card {  
    enum Kind { CLOVER, HEART, DIAMOND, SPADE } // 열거형 Kind를 정의  
    enum Value { TWO, THREE, FOUR } // 열거형 Value를 정의  
    
    final Kind kind; // 타입이 int가 아닌 Kind임에 유의  
    final Value value;  
}  
```  
  
자바의 열거형은 타입에 안전한 열거형이라서 실제 값이 같아도 타입이 다르면 컴파일 에러가 발생한다.  
열거형 상수를 사용하면, 기존의 소스를 다시 컴파일하지 않아도 된다.  
```  
if(Card.kind.CLOVER == Card.Value.TWO) // 컴파일 에러. 값은 같지만 타입이 다름  
```  
  
  
## 12.3 애너테이션(annotation)  
### 12.3.1 애너테이션이란?  
프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 바로 애너테이션이다.  
애너테이션은 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있다.  
  
JDK에서 제공하는 표준 애너테이션은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공한다.  
그리고 새로운 애너테이션을 정의할 때 사용하는 메타 애너테이션을 제공한다.  
(JDK에거 제공하는 애너테이션은 java.lang.annotation 패키지에 포함되어 있다.)  
  
  
  
# Chapter 13 쓰레드(thread)  
## 13.1 프로세스와 쓰레드  
프로세스란 실행 중인 프로그램이다.  
프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 된다.  
  
프로세스의 자원을 이용해서 실제로 작업을 수행하는 것이 바로 '쓰레드'이다.  
모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재하며, 둘 이상의 쓰레드를 가진 프로세스를 '멀티쓰레드 프로세스'라고 한다.  
멀티쓰레딩은 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 수행하는 것이다.  
교착상태란 두 쓰레드가 자원을 점유한 상태에서 서로 상대편이 점유한 자원을 사용하려고 기다리느라 진행이 멈춰있는 상태를 말한다.  
  
윈도우나 유닉스를 포함한 대부분의 OS는 멀티태스킹(multi-tasking, 다중작업)을 지원하기 때문에 여러 개의 프로세스가 동시에 실행될 수 있다.  
  
  
  
# Chapter 14 람다와 스트림  
## 14.1 람다식(Lambda expression)  
자바가 1996년에 처음 등장한 이후로 두 번의 큰 변화가 있었는데,  
한번은 JDK1.5부터 추가된 지네릭스(generics)의 등장이고,  
또 한번은 JDK1.8부터 추가된 람다식의 등장이다.  
  
특히 람다식의 도입으로 인해, 이제 자바는 객체지향언어인 동시에 함수형 언어가 되었다.  
  
  
  
### 14.1.1 람다식이란?  
람다식은 간단히 말해서 메서드를 하나의 '식(expression)'으로 표현한 것이다.  
람다식은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다.  
메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 익명 함수(anonymous function)이라고도 한다.  
```  
int[] arr = new int[5];  
Arrays.setAll(arr, (i) -> (int)(Math.random()*5)+1);  
```  
```  
int method() {  
    return (int) (Math.random()*5) + 1;  
}  
```  
  
  
  
# Chapter 15 입출력(I/O)  
## 15.1 자바에서의 입출력  
### 15.1.1 입출력이란?  
입출력은 컴퓨터 내부 또는 외부의 장치와 프로그램간의 데이터를 주고받는 것을 말한다.  
  
  
  
### 15.1.2 스트림(stream)  
스트림이란 연속적인 데이터의 흐름을 물에 비유해서 붙여진 이름이다.  
연속적인 데이터의 흐름을 물에 비유해서 붙여진 이름인데, 단방향통신만 가능하기 때문에 하나의 스트림으로 입력과 출력을 동시에 처리할 수 없다.  
먼저 보낸 데이터를 먼저 받게 되어 있으며, 중간에 건너뜀 없이 연속적으로 데이터를 주고 받는다.  
(큐와 같은 FIFO 구주로 되어 있다고 생각하면 이해하기 쉽다.)  
  
  
  
# Chapter 16 네트워킹(Networking)  
## 16.1 네트워킹(Networking)  
네트워킹이란 두 대 이상의 컴퓨터를 케이블로 연결하여 네트워크를 구성하는 것을 말한다.  
자바에서 제공하는 java.net패키지를 사용하면 이러한 네트워크 어플리케이션의 데이터 통신 부분을 쉽게 작성 할 수 있으며,  
간단한 네트워크 어플리케이션은 단 몇 줄의 자바코드 만으로도 작성이 가능하다.  
  
  
### 16.1.1 클라이언트/서버(client/server)  
서버는 서비스를 제공하는 컴퓨터이고, 클라이언트는 서비스를 사용하는 컴퓨터가 된다.  
웹서버에 접속하여 정보를 얻기 위해서는 웹브라우저(클라이언트 프로그램)가 있어야 히고,  
FTP서버에 접속해서 파일을 전송받기 위해서는 알 FTP와 같은 FTP클라이언트 프로그램이 필요하다.  
  
네트워크를 구성할 때 전용서버를 두는 것을 '서버기반 모델(server-based model)'이라 하고,  
별도의 전용서버없이 각 클라이언트가 서버역할을 동시에 수행하는 것을 'P2P모델(peer-to-peer)'이라 한다.  
  
서버 기반 모델과 P2P 모델간의 비교  
1. 서버기반 모델(server-based model)  
- 안정적인 서비스의 제공이 가능하다.  
- 공유 데이터의 관리와 보안이 용이하다.  
- 서버구축비용과 관리비용이 든다.  
  
2. P2P 모델(peer-to-peer model)  
- 서버구축 및 운용비용을 절감할 수 있다.  
- 자원의 활용을 극대화 할 수 있다.  
- 자원의 관리가 어렵다.  
- 보안이 취약하다.  
  
  
  
### 16.1.2 IP주소(IP address)  
IP주소는 컴퓨터(호스트, host)를 구별하는데 사용되는 고유한 값으로 인터넷에 연결된 모든 컴퓨터는 IP주소를 갖는다.  
IP주소는  4 byte의 정수로 구성되어 있으며, 4개의 정수가 마침표를 구분자로 표현된다.  
IP주소는 다시 네트워크주소와 호스트주소로 나눌 수 있는데, 네트워크를 어떻게 구성하였는지에 따라 달라진다.  
서로 다른 두 호스트의 IP주소의 네트워크주소가 같다는 것은 두 호스트가 같은 네트워크에 포함되어 있다는 것을 의미한다.  
(IP주소와 서브넷 마스크를 '&'연산하면 네트워크 주소를 얻어낼 수 있다.)  
  
  
  
### 16.1.3 InetAddress  
자바에서는 IP주소를 다루기 위한 클래스로 InetAddress를 제공한다.  
하나의 도메인명에 여러 IP주소가 맵핑될 수 있고 그 반대의 경우도 가능하다.  
  
  
  
### 16.1.4 URL(Uniform Resource Locator)  
URL은 인터넷에 존재하는 여러 서버들이 제공하는 자원에 접근할 수 있는 주소를 표현하기 위한 것이다.  
``프로토콜://호스트명:포트번호/경로명/파일명?쿼리스트링#참조``의 형태로 이루어져 있다.  
  
ex) http://www.codechobo.com:80/sample/hello.html?referer=codechobo#index1  
1. 프로토콜: 자원에 접근하기 위해 서버와 통신하는데 사용되는 통신규약(http)  
2. 호스트명: 자원을 제공하는 서버의 이름(www.codechobo.com)  
3. 포트번호: 통신에 사용되는 서버의 포트번호(80)  
4. 경로명: 접근하려는 자원이 저장된 서버상의 위치(/sample/)  
5. 파일명: 접근하려는 자원의 이름(hello.html)  
6. 쿼리(query): URL에서 '?'이후의 부분(referer=codechobo)  
7. 참조(anchor): URL에서 '#'이후의 부분(index1)  
  
자바에서는 URL을 다루기 위한 클래스로 URL 클래스를 제공한다.  
  
  
  
### 16.1.5 URLConnection  
URLConnection은 어플리케이션과 URL간의 통신연결을 나타내는 클래스의 최상위 클래스로 추상클래스이다.  
  
  
  
### 16.2 소켓 프로그래밍  
소켓이(socket)이란 프로세스간의 통신에 사용되는 양쪽 끝단을 의미한다.  
자바에서는 java.net패키지를 통해 소켓 프로그래밍을 지원하는데, 소켓통신에 사용되는 프로토콜에 따라 다른 종류의 소켓을 구현하여 제공한다.  
  
  
  
### 16.2.1 TCP와 UDP  
TCP/IP 프로토콜은 이기종 시스템간의 통신을 위한 표준 프로토콜로 프로토콜의 집합이다.  
TCP와 UDP 모두 TCP/IP 프로토콜(TCP/IP protocol suites)에 포함되어 있으며, OSI 7계층의 전송계층(transport layer)에 해당하는 프로토콜이다.  
  
TCP와 UDP의 비교(전화 VS 소포)  
1.TCP  
연결방식: 연결기반(연결 후 통신, 1:1 통신방식)  
특징:  
-데이터의 경계를 구분안함  
-신뢰성 있는 데이터 전송(데이터 전송순서 보장, 데이터의 수신여부 확인, 패킷을 관리할 필요가 없음)  
-UDP보다 전송속도가 느림  
관련클래스: Socket, ServerSocket  
  
  
2.UDP  
연결방식: 비연결기반(연결없이 통신, 1:1 or 1:N or N:N 통신방식)  
특징:  
-데이터의 경계를 구분함  
-신뢰성 없는 데이터 전송(데이터 전송순서 미보장, 데이터의 수신여부 미확인, 패킷을 관리해주아야 함)  
-TCP보다 전송속도가 빠름  
관련클래스: DatagramSocket, DatagramPacket, MulticastSocket  
  
  
  
### 16.2.3 UDP 프로그래밍  
UDP는 연결지향적인 프로토콜이 아니기 때문에, UDP 통신에서 사용하는 소켓은 DatagramSocket이며 데이터를 DatagramPacket에 담아서 전송한다.  
DatagramPacket은 헤더와 데이터로 구성되어 있다.  
헤더에는 DatagramPacket을 수신할 호스트의 정보(호스트의 주소와 포트)가 저장되어 있다.  
그래서 DatagramPacket을 전송하면 DatagramPacket에 지정된 주소(호스트의 주소)의 DatagramSocket에 도착한다.  
  
클라이언트가 DatagramPacket을 생성해서 DatagramSocket으로 서버에 전송하면,  
서버는 전송받은 DatagramPacket의 getAddress(), getPort()를 호출해서 클라이언트의 정보를 얻어  
서버시간을 DatagramPacket()에 담아서 전송한다.  
  
  
  
끝  