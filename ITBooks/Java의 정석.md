# Java의 정석 3rd Edition  
### 남궁 성 지음  
  
  
# Chapter 06 객체지향 프로그래밍1(Object-oriented Programming 1)  
  
## 1. 객체지향언어  
### 1.1 객체지향언어의 역사  
객체지향이론의 기본 개념은 '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.'라는 것이다.  
자바가 1995년에 발표되고 1990년대 말에 인터넷의 발전과 함께 크게 유행하면서 객체지향언어는 이제 프로그래밍언어의 주류로 자리 잡았다.  
  
  
### 1.2 객체지향언어  
객체지향언어의 주요특징은 다음과 같다.  
1. 코드의 재사용성이 높다.  
-새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.  
  
2. 코드의 관리가 용이하다.  
-코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.  
  
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.  
-제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며,  
코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.  
  
핵심: 너무 객체지향개념에 얽매여서 고민하기 보다는 일단 프로그램을 기능적으로 완성한 다음,  
어떻게 하면 보다 객체지향적으로 코드를 개선할 수 있을지를 고민하여 점차 개선해나가는 것이 좋다.  
  
  
  
## 2. 클래스와 객체  
### 2.1 클래스와 객체의 정의와 용도  
클래스의 정의: 클래스란 객체를 정의해 놓은 것이다.(객체의 설계도)  
클래스의 용도: 클래스는 객체를 생성하는데 사용된다.  
  
객체  
1. 사전적인 정의: 실제로 존재하는 것.  
2. 객체지향이론에서의 정의: 사물과 같은 유형적인 것 뿐만 아니라, 개념이나 논리와 같은 무형적인 것들도 객체로 간주한다.  
3. 프로그래밍에서의 정의: 클래스에 정의된 내용대로 메모리에 생성된 것.  
  
객체는 변수들의 컬렉션으로 정의할 수있다.  
간단하거나 복잡한 개체(entity)와 개체들에 관련된 연산을 제공하는 메서드들의 모음을 나타내기 때문이다.  
따라서 객체에는 상태와 행위가 있다고 생각하면 이해하기 쉽다.  
(원시타입을 제외하면 자바 언어의 다른 모든 변수들은 참조 타입이다. 이들은 객체라고 더 잘 알려져 있으며, 빈 객체를 의미하는 표현인 null이 존재한다.)  
즉, 변수들이 null로 설정될 수 있으며 메서드 또한 null을 반환할 수 있다. 그러나 null 참조에 대한 메서드를 호출할 수는 없다.  
  
객체에 선언하는 final 키워드는 원시 타입에 선언하는 final 키워드와 동일한 역할을 한다.  
즉, 변수 정의에서 지정된 값처럼 일단 할당이 되고 나면 메모리 위치가 변경되지 않는다.  
단, 객체 참조는 변경할 수 없어도 객체 내부의 값들은 개별 값들이 final이 아니라면 변경할 수 있다.  
  
클래스와 객체의 관계는 "제품의 설계도와 제품"의 관계라고 할 수 있다.  
예를들어 TV설계도는 TV라는 제품을 정의한 것이며, TV를 만드는데 사용된다.  
  
JDK(Java Develpment Kit)에서는 프로그래밍을 위해 많은 수의 유용한 클래스(Java API)를 기본적으로 제공하고 있으며,  
우리는 이 클래스들을 이용해서 원하는 기능의 프로그램을 보다 쉽게 작성할 수 있다.  
  
  
#### JDK(Java Development Kit)  
자바 응용 개발 환경으로, 개발에 필요한 도구 포함한다.(컴파일러, JRE, 클래스 라이브러리, 샘플 등)  
설치과정은 http://java.sun.com에서 Java SE를 다운로드하여 환경변수를 설정 후, DOS 창에서 JDK를 확인한다.  
  
  
### 2.2 객체와 인스턴스  
클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며,  
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.  
결국 인스턴스는 객체와 같은 의미이지만,  
객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있으며,  
인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 갖고 있다.  
(즉, 비슷한 성질을 가진 여러 개의 객체를 만들기 위해서, 클래스의 생성자 함수를 통해 생성된 객체)  
(객체 ⊃ 인스턴스)  
  
문맥에 따라 구별하여 사용하는 것이 좋다.  
1. 책상은 인스턴스다. VS 책상은 객체다.  
2. 책상은 책상 클래스의 객체이다. VS 책상은 책상 클래스의 인스턴스이다.  
  
  
### 2.3 객체의 구성요소 - 속성과 기능  
객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있다.  
속성과 기능은 같은 뜻의 여러 가지 용어가 있는데, 이 책에서는 속성은 멤버변수로, 기능은 메서드로 주로 사용하여 표현한다.  
속성(property): 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)  
기능(function): 메서드(method), 함수(function), 행위(behavior)  
  
TV를 예로 들면, TV의 속성으로는 전원상태, 크기, 길이, 높이, 색상, 볼륨, 채널과 같은 것들이 있으며,  
기능으로는 켜기, 끄기, 볼륨 높이기, 채널 변경하기 등이 있다.  
객체지향 프로그래밍에서는 속성과 기능을 각각 변수와 메서드로 표현한다.  
채널 -> ``int channel;``  
채널 높이기 -> ``channelUp() {...}``  
전원상태 -> ``boolean power;``  
전원 변경 -> ``void power() { power = !power; }``
- (생각해보기) if문을 사용한다면?  
```  
if(power) {  
    power = false;  
} else {  
    power = true;  
}  
```  
  
  
### 2.4 인스턴스의 생성과 사용  
클래스로부터 인스턴스를 생성하는 방법은 여러 가지가 있다.  
```  
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언.  
Tv t; // Tv클래스 타입의 참조변수 t를 선언. 메모리에 참조변수 t를 위한 공간이 마련된다. 아직 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 할 수 없다.  
  
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장.  
t = new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장. 
              // 1. 연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성된다.   
              // 2. 이 때 멤버변수는 각 자료형에 해당하는 기본값으로 초기화된다. String -> null, boolean -> false, int -> 0  
              // 3. 대입연산자에 의해서 생성된 객체의 주소값이 참조변수 t에 저장된다.(참조변수 t가 Tv인스턴스를 '가리키고 있다' 또는 '참조하고 있다'라고 한다.)  
```  
  
인스턴스와 참조변수의 관계는 마치 우리가 일상생활에서 사용하는 "TV와 TV리모콘"의 관계와 같다.  
TV리모콘(참조변수)을 사용하여 TV(인스턴스)를 다루기 때문이다.  
즉, TV인스턴스를 사용하려면, Tv클래스 타입의 참조변수가 필요한 것이다.  
(인스턴스는 참조변수를 통해서만 다룰 수 있으며, (기본적으로는)참조변수의 타입은 인스턴스의 타입과 일치해야 한다.)  
  
참고: 자신을 참고하고 있는 참조변수가 하나도 없는 인스턴스는 더 이상 사용되어질 수 없으므로,  
가비지컬렉터에 의해 자동적으로 메모리에서 제거된다.  
  
  
### 2.5 객체 배열  
객체 역시 배열로 다루는 것이 가능하며, 이를 '객체 배열'이라고 한다.  
객체 배열 안에 객체가 저장되는 것이 아니라, 객체의 주소가 저장된다.  
(참조변수들을 하나로 묶은 참조변수 배열인 것이다.)  
```  
Tv tv1, tv2, tv3;  
-> Tv[] tvArr = new Tv[3];  // 각 요소는 참조변수의 기본값인 null로 자동 초기화 된다.  
-> Tv[] tvArr = { new Tv(), new Tv(), new Tv() };  // 초기화블럭 사용시  
```  
  
다형성을 배우고 나면, 하나의 배열로 여러 종류의 객체를 다룰 수 있게 된다.  
  
  
### 2.6 클래스의 또 다른 정의  
프로그래밍 관점에서의 클래스는 서로 연관된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이다.  
  
사용자 정의 타입  
프로그래머가 서로 연관된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것.  
(클래스가 곧 사용자 정의 타입이다.)  
기본형의 개수가 8개이지만, 참조형의 개수가 정해져 있지 않은 이유는 이처럼 프로그래머가 새로운 타입을 추가할 수 있기 때문이다.  
  
  
  
## 3. 변수와 메서드  
### 3.1 선언위치에 따른 변수의 종류  
변수는 클래스변수, 인스턴스변수, 지역변수 모두 세 종류가 있다.  
변수의 종류를 결정짓는 중요한 요소는 '변수의 선언된 위치'이다.  
(선언 위치가 클래스 영역이면 멤버변수, 클래스 영역 이외면 지역변수이다.)  
  
즉, 멤버변수를 제외한 나머지 변수들은 모두 지역변수이며, 멤버변수 중 static이 붙은 것은 클래스변수, 붙지 않은 것이 인스턴스변수이다.  
(멤버변수는 인스턴스변수와 static 변수를 모두 통칭하는 말이다.)  
```  
class Variables {  
    int iv; // 인스턴스 변수  
    static int cv; // 클래스변수  
    
    void method() { // 메서드 영역  
        int lv = 0; // 지역변수  
    }  
}  
```  
  
생성시기  
1. 클래스변수: 클래스가 메모리에 올라갈 때  
(참조변수의 선언이나 객체의 생성과 같이 클래스의 정보가 필요할 때, 클래스는 메모리에 로딩된다.)  
2. 인스턴스변수: 인스턴스가 생성되었을 때  
3. 지역변수: 변수 선언문이 수행되었을 때  
  
클래스변수 vs 인스턴스변수  
인스턴스는 독릭적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.  
인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스변수로 선언한다.  
이와 달리, 클래스변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다.  
한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스변수로 선언해야 한다.  
또한, 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있으며, 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때 까지 유지된다.  


#### static  
static은 원리를 알고 잘 사용하면 시스템의 성능을 향상시킬 수 있다.  
1. static으로 선언한 변수는 객체의 변수가 되는 것이 아니라 클래스변수가 된다.  
2. 클래스변수를 포함한 클래스의 인스턴스를 여러 개 생성하더라도, 모든 객체가 클래스 변수에 대해서는 동일한 주소의 값을 참조한다.  
-> 다른 JVM 에서는 static이라고 선언해도 다른 주소나 다른 값을 참조하지만, 하나의 JVM이나 WAS 인스턴스에서는 같은 주소에 존재하는 값을 참조한다.  
  
3. GC의 대상이 되지 않는다. 이는 곧 OutOfMemoryError 를 발생시킬 수 있으며, 이 경우 해당 인스턴스는 더이상 서비스할 수 없어서 시스템을 재시작해야 한다.  
-> 더 이상 사용 가능한 메모리가 없어지는 현상을 메모리릭이라고 하며, 원인은 메모리의 현재 상태를 파일로 남기는 HeapDump라는 파일을 통해서 확인 가능하다. JDK/bin 디렉토리에 있는 jmap이라는 파일을 사용하여 덤프를 남길 수 있으며, 남긴 덤프는 eclipse 프로젝트에서 제공하는 MAT와 같은 툴을 통해서 분석하면 된다.  
  
4. static을 잘못 사용하는 예로  다음을 기억해 두자.  
``private static boolean successFlg; // 응시자의 합격 여부 ``  
수십 명이 동시에 자신의 정보를 호출한다면, 다른 사용자의 요청에 의해 다른 결과를 받게 된다.  
  
  
### 3.2 클래스변수와 인스턴스변수  
-사용 예시로 생략  
  
  
### 3.3 메서드  
특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것으로, 기본적으로 수학의 함수와 유사하다.  
메서드가 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐,  
이 메서드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 전혀 몰라도 된다.  
(입력과 출력만 알면 된다.)  
    
메서드를 사용하는 이유  
1. 높은 재사용성  
2. 중복된 코드의 제거  
3. 프로그램의 구조화  
-main메서드 안에 모든 문장을 넣는 식으로 프로그램을 작성하는 것보다는,  
문장들을 작업단위로 나눠서 여러 개의 메서드에 담아 프로그램의 구조를 단순화시키는 것이 좋다.  
  
  
### 3.4 메서드의 선언과 구현  
메서드의 이름은 이름만으로도 메서드의 기능을 쉽게 알 수 있도록 함축적이면서도 의미있는 이름을 짓도록 노력해야 한다.  
  
  
### 3.5 메서드의 호출  
메서드를 호출할 때 괄호()안에 지정해준 값들을 '인자(argument)' 또는 '인수'라고 한다.  
인자는 메서드가 호출되면서 매개변수에 대응되므로, 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.  
  
인자(인수) VS 매개변수  
-호출할 때 지정해준 값 VS 메서드 선언부  
  
같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만,  
static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.    
(유틸리티 함수를 만드는데 유용하게 사용된다.)  
```  
class Test {  
    Test () {}  
    static void m1 () {}  
    void m2 () {}  
}  
Test.m1() // O  
Test.m2() // X  

Test test = new Test();  
test.m1() // X  
test.m2() // O  
출처: https://mygumi.tistory.com/253 [마이구미의 HelloWorld]  
```  
  
  
### 3.6 return문  
원래는 모든 메서드에는 적어도 하나의 return 문이 있어야 한다.  
반환타입이 void인 경우, return문 없이도 아무런 문제가 없었던 이유는 컴파일러가 메서드의 마지막에 'return;'을 자동적으로 추가해주었기 때문이다.  
```  
(생각해보기)  
int add(int x, int y) {  
    int result = x + y;  
    return result;  
}  

int add(int x, int y) {  
    return x + y;  
}  
```  
  
매개변수의 유효성 검사  
매개변수의 값을 보정하는 것이 불가능하다면, return 문을 통해 작업을 중단하고, 호출한 메서드로 되돌아 가야 한다.  
  
  
### 3.7 JVM의 메모리구조  
응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.  
3가지 주요 영역(method area, call stack, heap)이 있다.  
  
1. 메서드 영역(method area)  
-프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(``*.class``)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다.  
이 때, 그 클래스의 클래스변수(``class variable, ex)static int cv;``)도 이 영역에 함께 생성된다.  
즉, static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.  
  
2. 호출 스택(call stack)  
-지역변수   
  
3. 힙(heap)  
-인스턴스가 생성되는 공간이다. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.  
(즉, 인스턴스변수(instance variable)들이 생성되는 공간이다.)  
즉, 프로그래머가 관리하는 메모리 영역이으로 new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.  
  
  
#### 메모리 상수풀 영역  
힙영역에 생성되어 자바 프로세스 종료까지 계속 유지되는 메모리영역.  
기본적으로 JVM에서 관리하며 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고  
없으면 상수풀에 추가한 이후 그 주소값을 리턴한다.  
그로 인해 메모리 절약 효과가 있다.  
  

### 호출 스택(call stack)  
호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다.  
메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며,  
이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다.  
메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.  
즉, 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리다.  
  
호출스택의 특징  
1. 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.  
2. 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.  
3. 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.  
4. 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.  
  
  
### 3.8 기본형 매개변수와 참조형 매개변수  
자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다.  
매개변수의 타입이 기본형일 때는 기본형 값이 복사되지만, 참조형이면 인스턴스의 주소가 복사된다.  
즉, 기본형 매개변수는 변수의 값을 읽기만 할 수 있고, 참조형 매개변수는 변수의 값을 읽고 변경할 수 있다.  
  
  
### 3.9 참조형 반환타입  
반환타입이 '참조형'이라는 것은 메서드가 '객체의 주소'를 반환한다는 것을 의미한다.  
즉, 모든 참조형 타입의 값은 객체의 주소이므로, 그저 정수값이 반환되는 것 일 뿐 특별한 것이 없다.  
  
가변인자(varargs)  
기존에는 메서드의 매개변수가 고정적이었으나 JDK 1.5부터는 동적으로 지정해 줄 수 있게 되었다.  
이 기능을 가변인자라고 한다. 가능하면 가변인자를 사용한 메서드는 오버로드하지 않는 것이 좋다.  
  
  
### 3.10 재귀호출(recursive call)  
반복문 대신 재귀호출을 사용하는 이유는 재귀호출이 주는 논리적 간결함 때문이다.  
아무리 효율적이라도 알아보기 힘들게 작성하는 것보다는,  
다소 비효율적이라도 알아보기 쉽게 작성하는 것이 논리적 오류가 발생할 확률도 줄어들고, 나중에 수정하기도 좋다.  
  
스택오버플로우와 같은 에러가 발생할 수 있다.  
  
  
### 3.11 클래스 메서드(static메서드)와 인스턴스 메서드  
(멤버변수는 인스턴스변수와 static 변수를 모두 통칭하는 말이다.)  
1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.  
2. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.  
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.  
-인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다.  
 인스턴스 변수가 존재한다는 것은 static변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.  
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.  
-메서드 호출시간이 짧아지므로 성능이 향상된다.  
  
  
### 3.12 클래스 멤버와 인스턴스 멤버간의 참조와 호출  
같은 클래스에 속한 멤버들 간에도 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다.  
단, 클래스멤버가 인스턴스 멤버들 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.  
(인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.)  
```  
class TestClass {  
    void instanceMethod() {} // 인스턴스메서드  
    static void staticMethod() {} // static메서드  
    
    void instanceMethod2() {  
        instanceMethod();  
        staticMethod();  
    }  
    
    void staticMethod2() {  
        instanceMethod();	// 에러  
        staticMethod();  
    }  
}  
```  
  
실제로는 같은 클래스 내에서 클래스멤버가 인스턴스멤버를 참조 또는 호출해야하는 경우는 드물다.  
만일 그런 경우가 발생한다면, 인스턴스메서드로 작성해야할 메서드를 클래스메서드로 한 것은 아닌지 한 번 더 생각해봐야 한다.  
  
  
#### 사용 자제해야할 메서드  
1. ``static void gc()``  
자바에서 사용하는 메모리를 명시적으로 해제하도록 GC를 수행하는 메서드다.  
2. ``System.exit(int status)``  
현재 수행중인 JVM을 종료하는 메서드로, 매개변수인 int 값은 정상종료인지 아닌지를 나타내는 상태코드이다. 0은 정상종료를, 그렇지 않은 숫자는 비정상 종료를 의미한다.  
3. ``static void runFinalization()``  
Object 객체에 있는 finalize()라는 메서드는 자동으로 호출되는데, 가비지 콜렉터가 알아서 해당 객체를 더 이상 참조할 필요가 없을 때 호출한다. 이 메서드를 호출하면 참조 해제 작업을 기자리는 모든 객체의 finalize() 메서드를 수동으로 수행해야 한다.  
  
  
## 5. 생성자(Constructor)  
``Card c = new Card();``  
1. 연산자 new에 의해 메모리(heap)에 card 클래스의 인스턴스가 생성된다.  
2. 그 다음 생성자 card()가 호출되어 수행된다.  
3. 결과로 생성된 card 인스턴스의 주소가 반환되어 참조변수 c에 저장된다.  
  
  
  
# Chapter 07 객체지향 프로그래밍2(Object-oriented Programming 2)  
## 1. 상속 (inheritance)  
### 1.1 상속의 정의와 장점  
1. 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.  
2. 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.  
(접근 제어자가 private 또는 default인 멤버들은 상속되지 않는다기보다는  
상속은 받지만 자손 클래스로부터의 접근이 제한되는 것이다.)  
  
자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.  
  
  
### 1.4 단일 상속(single inheritance)  
클래스를 이용하여 다중 상속을 할 경우 메서드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어서  
자바에서는 클래스를 통한 다중 상속은 지원하지 않는다.  
(클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다는 점에서  
단일상속이 다중상속보다 유리하다.)  
  
  
### 상속 VS 다형성  
상속과 다형성은 객체 지향 개발의 두 가지 핵심 개념이다.  
상속은 부모클래스에서 클래스의 행동과 정의를 가져다 사용할 수 있게 해준다.  
새로운 클래스를 정의할 때 이전에 정의된 클래스에서 정의와 상태를 상속할 수 있고 새로운 행동을 추가하거나 새로운 타입에 대한 행동을 오버라이드할 수 있다.  
예들 들어, Square 클래스는 Rectangle을 상속한다.  
(정사각형 역시 사각형 is-a rectangle이라고 부를 수 있다.)  
  
다형성은 행동의 특정 타입에 대한 정의를 만들 수 있게 하고, 행동을 구현하는 수많은 다른 클래스들을 갖게 한다.  
부모 클래스를 요청했을 때 하위 클래스를 대신 사용하는 것으로도 생각할 수 있다.  
이때 하위 클래스의 행위는 유지되겠지만, 다형성을 사용하는 사용자가 하위클래스의 행위를 이해하지 못할 수 있다.  
따라서, Square 클래스에 구체적으로 정의되어 있는 메서드는 Rectangle 클래스에서는 사용할 수 없다.  
  
  
## 3. package와 import  
### 3.5 static import문  
import문을 사용하면 클래스의 패키지명을 생략할 수 있는 것과 같이  
static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다.  
  
특정 클래스의 static멤버를 자주 사용할 때 편리하며, 코드도 간결해진다.  
```  
import static java.lang.Math.random;  
import static java.lang.System.out;  
  
...  
//System.out.println(Math.random());  
out.println(random());  
...  
```  
  
  
## 4. 제어자(modifier)  
### 4.1 제어자란?  
클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.  
제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.  
접근제어자: public, protected, default, private  
그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp  
  
  
native: 자바에서 다른 언어를 사용할 수 있게 만들어주는 키워드.  
ex) JNI를 사용할 때, native 키워드가 사용된다.  
  
JNI(JAVA Native Interface): 자바로 만들어진 프로그램에서 특정 플랫폼에서만 실행되는 코드(Native Code)에 접근하기 위한 API이다.  
ex) c <-> java  
```  
톰캣 서버 DataSource 설정하는 context.xml 예시  
<?xml version="1.0" encoding="UTF-8"?>  
<Context path="/">  
    <WatchedResource>WEB-INF/web.xml</WatchedResource>  
    <Resource name="jdbc/knou" auth="Container" type="javax.sql.DataSource"  
              maxActive="10" maxIdle="3" maxWait="10000"  
              username="butterfield" password="1234"  
              driverClassName="com.mysql.cj.jdbc.Driver"  
              url="jdbc:mysql://localhost:3307/knou"  
              closeMethod="close" />  
</Context>  
```  
  
  
transient: Serialize(직렬화)하는 과정에서 제외하고 싶은 경우 선언하는 키워드.  
직렬화: 자바 시스템 내부에서 사용되는 Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte형태로 데이터를 변환하는 기술.  
  
volatile: thread에서 사용되는 것인데, cpu cache와 메인메모리에서의 read & write상에서의 불일치를 해결하기 위해 사용되는 키워드이다.  
(성능에 영향을 줄 수 있는 키워드라서 제한적으로 꼭 필요한 상황에만 써야 한다.)  
  
strictfp: 자바와 타 플랫폼간의 부동소수점의 정밀도를 맞춰주기 위한 키워드이다.  
  
  
### 4.5 접근 제어자(access modifier)  
제어자들 간의 순서는 관계없지만, 주로 접근제어자를 제일 왼쪽에 놓는 경향이 있다.  
  
### 생성자의 접근 제어자  
생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.  
생성자의 접근 제어자를  private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다.  
(그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.)  
```  
class Singleton {  
    private Singleton() {  
        ...  
    }  
    ...  
}  
```  
  
대신 인스턴스를 생성해서 반환해주는  public 메서드를 제공함으로써, 외부에서 이 클래스의 인스턴스를 사용하도록 할 수 있다.  
이 메서드는 public인 동시에 static이어야 한다.  
```  
class Singleton {  
    // getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로, static이어야 한다.  
    private static Singleton s = new Singleton();  
      
    private Singleton() {  
        ...  
    }  
    
    // 인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static이어야 한다.  
    public static Singleton getInstance() {  
        return s;  
    }  
    ...  
}  
```  
이처럼 생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 public메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한할 수 있다.  
  
  
### 4.6 제어자(modifier)의 조합  
제어자를 조합해서 사용할 때 주의해야 할 사항에 대해 정리  
1. 메서드에 static과 abstract를 함께 사용할 수 없다.  
-static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.  
  
2. 클래스에 abstract와 final을 동시에 사용할 수 없다.  
-클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고,  
abstract는 상속을 통해서 완성되어야 한다는 의미이므로, 서로 모순되기 때문이다.  
  
3. abstract메서드의 접근 제어자가 private일 수 없다.  
-abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다.  
  
4. 메서드에 private과 final을 같이 사용하 필요는 없다.  
-접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.  
  
  
## 6. 추상클래스(abstract class)  
### 6.1 추상클래스란?  
추상메서드를 하나 이상 가진 클래스.  
클래스 구현부 내부에 추상 메서드가 하나 이상 포함되고, abstract로 정의된 경우를 말한다.  
추상 메서드를 포함하고 있다는 점을 제외하면, 일반 클래스와 모든점이 같다.  
(생성자와 필드, 일반 메서드도 포함할 수 있다.)  

주의  
자신의 생성자로 인스턴스 생성 불가능하다.  
그래서 먼저 상속을 통해 자식 클래스를 만들고, 만들 자식 클래스에서 추상 클래스의 모든 추상 메서드를 오버라이딩하고 나서야  
비로소 자식클래스의 인스턴스를 생성할 수 있게 된다.  

목적  
즉, 하위 클래스를 제어하기 위해 사용한다.  
```
abstract class Animal {  
    abstract void cry();  
}  

class Cat extends Animal {  
    void cry() {  
        System.out.println("냐옹냐옹!");  
    }  
}  

class Dog extends Animal {  
    void cry() {  
        System.out.println("멍멍!");  
    }  
}  

public class Polymorphism02 {  
    public static void main(String[] args) {  
        // Animal a = new Animal(); // 추상 클래스는 인스턴스를 생성할 수 없음.  
        Cat c = new Cat();  
        Dog d = new Dog();  
        c.cry(); // 냐옹냐옹!  
        d.cry(); // 멍멍!  
    }  
}  
```


### 6.2 추상 메서드(abstract method)  
선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다.  
즉, 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메서드이다.  
목적은 추상메서드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상메서드를 구현하도록 하기 위함이다.  
(만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.)  



## 7. 인터페이스(interface)  
### 7.1 인터페이스란?  
인터페이스는 하위 클래스에 특정한 메서드가 반드시 존재하도록 강제한다.  
또한 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록 한다.  
실질적으로는 협업자 상호간에 동일한 메서드를 만들도록 규약을 만드는데 이용할 수 있다.  

특징으로 다중 상속이 가능하다.  
멤버는 반드시 public이며, 오직 추상메서드와 상수만을 멤버로 갖는다.  
일종의 추상 클래스이다.  
추상 클래스와 다르게 하나의 클래스가 여러 개의 인터페이스를 구현 할 수 있지만,  
구체적인 로직이나 상태를 가지고 있을 수 없다.  
```  
접근제어자 interface 인터페이스이름 {  
    public static final 타입 상수이름 = 값;  
    ...  
    public abstract 메서드이름(매개변수목록);  
    ...  
}  
```  


### Interface vs Abstract  
공통점  
1. new 연산자로 인스턴스 생성 불가능.  
2. 프로토타입만 있는 메서드를 갖는다.  
3. 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.  
(다른 클래스를 작성하는데 도움 줄 목적으로 작성된다.)  
4. 가지고 있는 추상메서드를 구현하도록 강제한다.  
  
차이점  
1. 클래스를 설계도에 비유한다면, 추상클래스를 부분적으로만 완성된 '미완성 설계도'이고,  
인터페이스는 구현된 것은 아무 것도 없고 밑그림만 그려져 있는 '기본 설계도'라 할 수 있다.  
2. 추상클래스는 일반 메서드를 사용할 수 있지만, 인터페이스는 메서드 선언만 가능하다.  
(인터페이스는 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.)  
3. 추상클래스는 어느정도 틀을 갖춘 상태에서 진행이 필요하거나, 관련성이 높은 클래스 간에 코드를 공유하고 싶은 경우 사용할 수 있다.  
4. 인터페이스는 다른 클래스를 작성하는데 도움을 줄 목적으로 작성된다. 다중상속을 허용하고 싶은 경우에 사용한다.  
  
  
## 8. 내부 클래스(inner class)  
클래스 내에 선언된다는 점을 제외하고는 일반적인 클래스와 다르지 않다.  

### 8.1 내부 클래스란?  
클래스 내에 선언된 클래스이다.  
클래스에 다른 클래스를 선언하는 이유는 두 클래스가 긴밀한 관계에 있기 때문이다.  

장점  
-내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.  
-외부에 불필요한 클래스르 감춤으로써 코드의 복잡성을 줄일 수 있다(캡슐화).  


### 8.5 익명 클래스(anonymous class)  
익명 클래스는 특이하게도 다른 내부 클래스들과는 달리 이름이 없다.  
클래스의 선언과 객체의 생성을 동시에 하기 때문에  
단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.  
```  
    new 조상클래스이름() {  
        // 멤버 선언  
    }  
    
    // 또는  
    new 구현인터페이스이름() {  
        // 멤버 선언  
    }  
```  
  
  
이름이 없기 때문에 생성자도 가질 수 없으며,  
조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기 때문에  
하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다.  
즉, 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.  

예제7-36/ch7/InnerEx6.java를 컴파일 하면 4개의 클래스 파일이 생성된다.  
``// C:\gitWorkspace\privateCS2\bin\ch7``  
익명 클래스는 이름이 없기 때문에 ``외부 클래스명$숫자.class``의 형식으로 클래스 파일명이 결정된다.  

독립된 클래스를 익명클래스를 이용하여 변경하면 보다 쉽게 코드를 작성할 수 있다.  
-> 형상관리 솔루션에서는?  
  
  
# Chapter 08 예외처리(Exception Handling)  
## 1. 예외처리(exception handling)  
### 1.1 프로그램 오류  
컴파일 에러: 컴파일 시에 발생하는 에러  
런타임 에러: 실행 시에 발생하는 에러  
논리적 에러: 실행은 되지만, 의도와 다르게 동작하는 것  

에러: 프로그램 코드에 의해서 수습될 수 없는 심각한 오류  
-메모리 부족, 스택오버플로우  
예외: 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류  
  
  
### 1.2 예외 클래스의 계층구조  
Exception과 Error클래스 역시 Object클래스의 자손들이다.  
Excetpion클래스들: 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외  
-존재하지 않는 파일의 이름을 입력했다던가, 실수로 클래스의 이름을 잘못 적었다던가, 입력한 데이터 형식이 잘못된 경우에 발생.  
RuntimeException클래스들: 프로그래머의 실수로 발생하는 예외  
-배열의 범위를 벗어난다던가, 값이 null인 참조변수의 멤버를 호출하려 했다던가, 클래스간의 형변환을 잘못했다던가, 정수를 0으로 나누려고하는 경우에 발생.  
  
  
### 1.3 예외처리하기 - try-catch문  
예외처리(exception handling)  
정의: 프로그램 실행 시 발생할 수 있는 예외에 대비한 코드를 작성하는 것.  
목적: 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것.  
(에러와, 예외는 모두 실행 시(runtime) 발생하는 오류이다.)  

실수를 0으로 나누는 것은 금지되어있지 않으며 예외가 발생하지 않는다?  
  
  
### 1.4 try-catch문에서의 흐름  
생략.  
  
  
### 1.5 예외의 발생과 catch블럭  
예외가 발생하면, 발생한 예외에 해당하는 클래스의 인스턴스가 만들어 진다.  
첫번째 catch블럭부터 차례로 내려가면서 catch블럭의 괄호()내에 선언된 참조변수의 종류와  
생성된 예외클래스의 인스턴스에 instanceof연산자를 이용해서 검사하게 되는데,  
검사결과가 true인 catch블럭을 만날 때까지 검사는 계속된다.  
  
printStackTrace(): 예외발생 당시의 호출스택에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.  
-printStackTrace(PrintStream s) 또는 printStackTrace(PrintWriter s)를 사용하면 발생한 예외에 대한 정보를 파일에 저장할 수도 있다.  
getMessage(): 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.  
  
  
### 1.6 예외 발생시키기  
컴파일러가 예외처리를 확인하지 않는 RuntimeException클래스들은 'unchecked예외'라고 부르고,  
예외처리를 확인하는 Exception클래스들은 'checked예외'라고 부른다.  
  
  
### 1.7 메서드에 예외 선언하기  
생략.  
  
  
### 1.8 finally블럭  
try블럭에서 return문이 실행되는 경우에도 finally블럭의 문장들이 먼저 실행된 후에, 현재 실행 중인 메서드를 종료한다.  
이와 마찬가지로 catch블럭의 문장 수행 중에 return문을 만나도 finally블럭의 문장들은 수행된다.  
  
  
끝  