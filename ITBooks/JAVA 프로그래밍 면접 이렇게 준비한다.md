# JAVA 프로그래밍 면접 이렇게 준비한다  
  
## 노엘 마크엄 지음  
## 정원천 옮김  
  
  
## 처음 ~ p.49  
이 책은 Java SE 7에 기반을 두고 쓰여졌다. 2015년 1월 자바 최신 버전은 8로, 자바 8에서 주목을 받는 개념을 함께 다루고 있다.  
### 자바 7의 몇 가지 새로운 기능과 API  
1. 다이아몬드 연산자  
컴파일러가 제너릭 인스턴스의 타입을 추측할 수 있다.  
```  
//List<Integer> numbers = new ArrayList<Integer>();  
List<Integer> numbers = new ArrayList<>();  
```  
이렇게 작성하면 컬렉션을 이용할 때 많은 양의 코드를 줄일 수 있다.  
  
2. switch문에서 문자열 사용하기  
숫자타입입만 사용할 수 있었는데, 자바 5에서는 열거형 타입을, 자바 7에서는 문자열 객체를 사용할 수 있도록 발전했다.  
  
  
## p.50 ~ 84  
### 리스트 정렬하기  
Comparable과 Comparator 인터페이스의 차이는 무엇인가?  
- Comparable 인터페이스는 자연스러운 순서로 정렬할 때 사용하고, Comparator는 원하는 대로 정렬 순서를 지정하고 싶은 곳에 사용한다.  

### 정렬 알고리즘  
1. 버블정렬: 역순인 경우 O(n^2), 정렬이 되어있는 경우 O(n)  
2. 삽입정렬: 정렬이 되어 있는 경우 O(n^2), 역순인 경우 O(n)  
3. 퀵정렬: 정렬이 되어 있는 경우 O(n^2), 평균 O(n log n)  
4. 삽입정렬: O(n log n) 보장    
  
  
## p.102 ~ 108  
소프트웨어 디자인 패턴은 프로그램을 만들면서 발생할 수 있는 다양한 상황에 효율적으로 적용할 수 있는 해결책이다.  
보통 하나 이상의 객체를 함께 사용하며 코드 재사용, 확장성에 초점을 두거나  
앞으로 개발할 때 필요한 견고한 기반을 제공한다는 점에서 디자인 패턴은 알아두면 많은 도움이 된다.  

객체 지향 프로그래밍 언어인 자바는 표준 라이브러리 API를 통해 많은 디자인 패턴을 이용할 수 있게 구성되었다.  

### 빌더 패턴  
빌더 패턴을 사용하면 도메인에 적합한 객체를 생성하는 빌더라는 동반자 객체를 만들 수 있다.  
이것이 생성자를 이용하는 방법보다 더 깔끔하다.  
```  
// 빌더 패턴의 클래스 구현하기  
public class Pet {  
    public static class Builder {  
        private Animal animal;  
        private String perName;  
        
        public Builder withAnimal(final Animal animal) {  
            this.animal = animal;  
            return this;  
        }  
        
        public Builder withPetName(final String petName) {  
            this.petName = petName;  
            return this;  
        }  
        
        public Pet build() {  
            return new Pet(anial, petName);  
        }  
    }  
    
    private final Animal animal;  
    private final String petName;  
    
    private Pet(final Animal animal, final String petName) {  
        this.animal = animal;  
        this.petName = petName;  
    }  
}  
  
  
// 빌더 패턴으로 객체 생성하기  
@Test  
public void legalBuild() {  
    final Pet.Builder builder = new Pet.Builder();  
    final Pet pet = builder  
        .withAnimal(Animal.Cat)  
        .withPetName("Squidge")  
        .build();  
    // 예외 처리 없이 테스트가 통과함  
}  
```  
Builder 클래스는 Pet 클래스의 일부이며 Pet 객체를 생성하는 전적인 권한이 있다.  
각 매개변수에 명시적인 메서드가 있다면 각 값을 정확히 어떻게 사용하는지 이해하기도 쉽고,  
순서에 상관없이 호출하고 싶은 데로 호출할 수도 있다.  
(Build 메서드가 이런 명시적인 메서드 역할을 한다.)  
즉, Pet 객체의 실제 생성자를 호출해서 실제 Pet 객체를 반환한다.  
생성자는 이제 final 키워드를 뺀 private으로 선언할 수 있다.  
  
  
## p.156 ~ 165 
### 자바에서 객체란 무엇인가?  
객체는 변수들의 컬렉션으로 정의할 수 있다. 간단하거나 복잡한 개체(entity)와 개체들에 관련된 연산을 제공하는 메서드들의 모음을 나타내기 때문이다.  
따라서 객체에는 상태와 행위가 있다.  

변수들은 null로 설정될 수 있으며 메서드 또한 null을 반환할 수 있으나, Null 참조에 대한 메서드를 호출할 수는 없다.  

원시타입의 경우``(예를들어)int i = 42; int j = i;`` 메모리의 다른 위치에 같은 값을 할당하지만,  
``List myList = new ArrayList(20);`` 구문으로 생성된 객체를 변수에 할당할 때 myList는 할당된 메모리 위치를 가리킨다.  
즉, 한 인스턴스에 변경이 생기면 다른 인스턴스가 접근했을 때 영향을 미치게 된다는 뜻이다.  
  
  
### final 키워드는 객체 참조에 어떤 영향을 미치는가?  
객체에 선언하는 final 키워드는 원시 타입에 선언하는 final 키워드와 동일한 역할을 한다.  
즉, 변수 정의에서 지정된 값처럼 일단 할당이 되고 나면 메모리 위치가 변경되지 않는다.  
단, 객체 참조는 변경할 수 없어도 객체 내부의 값들은 개별 값들이 final이 아니라면 변경할 수 있다.  
```  
@Test  
public void finalReferenceChanges() {  
    final int i = 42;  
    // i = 43; //컴파일 에러  
    
    final List<String> list = new ArrayList<>(20);  
    // list = new ArrayList(50); // 컴파일 에러  
    assertEquals(0, list.size());  
    
    list.add("adding a newvalue into my list");  
    assertEquals(1, list.size());  
    
    list.clear();  
    assertEquals(0, list.size());  
}  
```    
  
  
### 객체의 가시성 수정자는 어떻게 작동하는가?  
private 멤버 변수는 오직 해당 클레스에서만 사용할 수 있다.(하위 클래스에서도 사용할 수 없다.)  
오직 해당 타입만 필요하다고 간주한다.  

일반적인 오해는 private으로 선언한 변수는 해당 인스턴스에만 접근할 수 있다고 생각하는 것이다.  
실제로 같은 타입의 다른 모든 인스턴스가 private 멤버 변수에 접근할 수 있다.  
보통은 타입이 같은지 확인할 때 다른 인스턴스의 private 멤버 변수에 접근하며,  
IDE 대부분은 변수에 접근할 때 필요한 올바른 hashcode와 equals 메서드를 만드는 데 도움을 준다.  
  
  
  
## p.245 ~ 249  
### 메모리는 어떻게 할당하는가?  
new 키워드는 자바 힙 영역에 메모리를 할당 한다. 힙은 애플리케이션 영역에 접근할 수 있는 메인 영역이다.  
객체를 할당할 때 이용할 수 있는 메모리가 충분치 않으면 JVM(자바 가상머신)은 가비지 컬렉션을 이용해 힙에서 메모리를 재사용하려고 시도한다.  
그래도 충분한 메모리 영역을 확보할 수 없다면 OutOfMemoryError가 발생하며 JVM이 종료된다.  

힙은 제너레이션이라는 몇 가지 영역으로 구분된다. 가비지 컬렉션에서 객체가 수집 대상에서 제외된다면 다른 제너레이션으로 옮겨진다.  
예를 들어 older제너레이션은 가비지 컬렉션에서 자주 수집하지 않는 객체가 저장되어 있다.  
이미 오랫동안 제거되지 않았음이 증명된 것이므로 가비지 컬렉션에서 수집할 가능성이 낮다.  
  
  
### 가비지 컬렉션이란 무엇인가?  
가비지 컬렉션은 기존에 할당된 메모리를 재사용하는 메커니즘으로, 나중에 메모리를 할당할 때 재사용할 수 있다.  
가비지 컬렉션 알고리즘은 몇가지가 있는데, 모든 작동 중인 코드에서 더 이상 참조하지 않는 메모리를 찾은 후 메모리를 할당할 때 이용할 수 있도록 반환한다는 공통의 목적이 있다.  
자바의 전통적인 가비지 컬렉션은 mark-and-swewp 방식이다.  
실행 중인 코드에서 참조하는 객체는 live로 표시되며 해당 객체에서 참조하는 것들 역시 확인해서 live로 표시한다. 이는 현재 동작하는 객체의 모든 경로가 확인될 때까지 계속된다.  
이 과정이 끝나면 힙에 있는 각 객체들을 찾아다니며 live로 표시되지 않은 메모리 위치에 메모리를 할당할 수 있게 만든다.  
이 과정이 진행되는 동안에는 메모리를 재배치하려고 JVM의 모든 스레드가 정지되는데, 이를 stop-the-world라고 한다.  

결국 가비지 컬렉션은 다른 제너레이션으로의 이동과 가능한 한 많은 여유 공간을 남겨두려는 목적으로 메모리에서 객체들을 옮기고 자주 접근되는 객체들을 묶어두는 등의 다른 연산을 수행한다.  
이것을 컴패션이라고 하며, 컴패션은 live로 표시한 객체들을 다른 물리적인 메모리 위치로 옮김으로서 JVM이 stop-the-wold인 동안 메모리 공간을 확보한다.  
  
  
  
## p.475 ~ 494  
### 메이븐이란 무엇인가?  
프로젝트의 자원을 모두 하나로 합치는 데 집중하는 애플리케이션인 메이븐과 앤트가 있다. 자바 프로젝트를 위해 가장 많이 사용되는 빌드 도구다.  
메이븐은 프로젝트 전체를 포괄하는 빌드 도구로, 자바 프로젝트를 컴파일, 테스트, 배포하는 데 사용된다.  
설정을 통해 만든 규칙을 따르도록 설계되어 있다.  
대부분의 자바 애플리케이션용 빌드는 매우 비슷한 방법으로 정의될 수 있으며, 비슷한 구조로 소스 코드를 작성하면 메이븐은 필요한 자원들을 어디서 찾아야 하는지 파악해 여러 가지 빌드 작업을 수행한다.  
  
메이븐에는 대부분의 프로젝트 설정이 기본으로 내장되어 있어 애플리케이션이 WAR(Web Archive)나 JAR 파일로 배포될 것이다.  
메이븐은 이 작업들을 어떻게 빌드해야 하는지에 대한 정의를 갖고 있다.  

메이븐의 플러그인 시스템은 빌드에 특정한 연산을 더 추가할 수 있게 해준다.  
의존성 설정과 비슷하게 이 플러그인들은 원격으로 제공되며, 메이븐은 빌드할 때 이들을 찾을 수 있다.  
또한 플러그인이 제공하는 연산이 무엇이든 실행할 수 있다.  
일반적인 플러그인의 예는 ``maven-jetty-plugin``인데, 이는 현재 빌드를 웹 애플리케이션 형태로 실행한다.  
이 플러그인은 프로젝트가 web.xml 파일을 ``src/main/webapp/WEB-INF`` 디렉터리에 두는 관습을 따른다는 가정 아래 적합한 web.xml 파일을 찾는다.  
이러한 역할을 수행하는 또다른 플러그인은 ``maven-release-plugin``이며, 출시 빌드용으로 코드를 나누고 애플리케이션의 버전 번호를 변경하기 위해 서브버전이나 Git 같은 소스 버전 관리 도구와 연계해서 복잡한 작업을 수행하고, 다음 개발주기를 준비한다.  
  
  
### 메이븐 빌드의 생명주기는 무엇인가?  
메이븐 빌드는 생명주기라는 일련의 상태로 구성되며 각 상태는 특정 골에 따라 구분된다.  
각 상태는 이전 상태에 의존하며 어떤 이유에서든 특정 골을 통한 작업에 문제가 발생하면 전체 빌드가 실패할 수밖에 없다.  
-기본상태  
1. clean  
2. validate -> compile -> test -> package -> install  
3. deploy  
  
어떤 빌드 결과물은 프로젝트 루트의 target이라는 디렉터리에 저장된다. clean상태의 골은 이 target 디렉터리를 지워서 이전에 빌드된 파일들을 없앤다.  
이는 mvn clean 같은 빌드 상태를 명시해서 초기화하거나 항상 실행되도록 POM(Project Object Model)에 정의하지 않으면 다음 상태가 되기 전에는 실행하지 않는다.  
  
validate 상태는 메이븐의 빌드 파일용 XML 사양을 따르는 올바른 pom.xml 파일인지 확인한다.  
compile 상태는 모든 정의된 의존성들을 가져오고, 코드를 컴파일하고, 모든 클래스 파일을 ``target/classes`` 디렉터리에 빌드한다.  
test 상태는 디렉터리에 있는 클래스들을 컴파일하고 디렉터리에 있는 모든 단위 테스트 또는 통합 테스트용 테스트 코드를 실행한다.  
package 상태는 WAR나 JAR파일 같은 결과물을 생성한다. 이 파일은 target 디렉터리의 루트에 저장된다.  
install 단계는 빌드된 결과물을 내부 메이븐 저장소로 보낸다. 대개 ``$HOME/.m2/repository``디렉터리에 위치한다.  
  
마지막 단계는 deploy 단계로, 마무리된 결과물을 배포하기 위한 장소가 어딘지 정확히 정의하는 추가 설정이 좀 더 필요하다.  
  
  
  