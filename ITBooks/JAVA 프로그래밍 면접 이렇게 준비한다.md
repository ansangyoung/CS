# JAVA 프로그래밍 면접 이렇게 준비한다  
  
## 노엘 마크엄 지음  
## 정원천 옮김  
  
  
## 처음  
이 책은 Java SE 7에 기반을 두고 쓰여졌다. 2015년 1월 자바 최신 버전은 8로, 자바 8에서 주목을 받는 개념을 함께 다루고 있다.  
  
### 자바 7의 몇 가지 새로운 기능과 API  
1. 다이아몬드 연산자  
컴파일러가 제너릭 인스턴스의 타입을 추측할 수 있다.  
```  
//List<Integer> numbers = new ArrayList<Integer>();  
List<Integer> numbers = new ArrayList<>();  
```  
이렇게 작성하면 컬렉션을 이용할 때 많은 양의 코드를 줄일 수 있다.  
  
2. switch문에서 문자열 사용하기  
숫자타입입만 사용할 수 있었는데, 자바 5에서는 열거형 타입을, 자바 7에서는 문자열 객체를 사용할 수 있도록 발전했다.  
  
  
  
## 03 기술 면접과 면접 기본 사항  
### 리스트 정렬하기  
Comparable과 Comparator 인터페이스의 차이는 무엇인가?  
- Comparable 인터페이스는 자연스러운 순서로 정렬할 때 사용하고,  
Comparator는 원하는 대로 정렬 순서를 지정하고 싶은 곳에 사용한다.  
  
  
  
## 04 기본 알고리즘 작성하기  
### 리스트  
예를 들어, 항상 리스트의 첫 번째 원소에만 데이터를 넣는다면 리스트 자료구조를 이용하는 것이 좋다.  
(리스트: 특정 타입 값들이 순차적으로 정렬된 컬렉션)  
자바의 리스트에는 ArrayList와 LinkedList가 있다.  
ArrayList 클래스는 리스트의 데이터로 배열을 사용하는 List 인터페이스의 구현체이다.  
LinkedList는 연결 리스트를 구현할 수 있는 또 다른 리스트 구현체이다.  
원소들을 저장하는 데 배열을 이용하지 않고, 리스트 안에서 다음 원소를 가리키는 내부 객체를 이용한다.  
  
  
### 정렬 알고리즘  
1. 버블정렬: 역순인 경우 O(n^2), 정렬이 되어있는 경우 O(n)  
2. 삽입정렬: 정렬이 되어 있는 경우 O(n^2), 역순인 경우 O(n)  
3. 퀵정렬: 정렬이 되어 있는 경우 O(n^2), 평균 O(n log n)  
4. 삽입정렬: O(n log n) 보장    
  
  
  
## 06 디자인 패턴  
소프트웨어 디자인 패턴은 프로그램을 만들면서 발생할 수 있는 다양한 상황에 효율적으로 적용할 수 있는 해결책이다.  
보통 하나 이상의 객체를 함께 사용하며 코드 재사용, 확장성에 초점을 두거나  
앞으로 개발할 때 필요한 견고한 기반을 제공한다는 점에서 디자인 패턴은 알아두면 많은 도움이 된다.  

객체 지향 프로그래밍 언어인 자바는 표준 라이브러리 API를 통해 많은 디자인 패턴을 이용할 수 있게 구성되었다.  

### 빌더 패턴  
빌더 패턴을 사용하면 도메인에 적합한 객체를 생성하는 빌더라는 동반자 객체를 만들 수 있다.  
이것이 생성자를 이용하는 방법보다 더 깔끔하다.  
```  
// 빌더 패턴의 클래스 구현하기  
public class Pet {  
    public static class Builder {  
        private Animal animal;  
        private String perName;  
        
        public Builder withAnimal(final Animal animal) {  
            this.animal = animal;  
            return this;  
        }  
        
        public Builder withPetName(final String petName) {  
            this.petName = petName;  
            return this;  
        }  
        
        public Pet build() {  
            return new Pet(anial, petName);  
        }  
    }  
    
    private final Animal animal;  
    private final String petName;  
    
    private Pet(final Animal animal, final String petName) {  
        this.animal = animal;  
        this.petName = petName;  
    }  
}  
  
  
// 빌더 패턴으로 객체 생성하기  
@Test  
public void legalBuild() {  
    final Pet.Builder builder = new Pet.Builder();  
    final Pet pet = builder  
        .withAnimal(Animal.Cat)  
        .withPetName("Squidge")  
        .build();  
    // 예외 처리 없이 테스트가 통과함  
}  
```  
Builder 클래스는 Pet 클래스의 일부이며 Pet 객체를 생성하는 전적인 권한이 있다.  
각 매개변수에 명시적인 메서드가 있다면 각 값을 정확히 어떻게 사용하는지 이해하기도 쉽고,  
순서에 상관없이 호출하고 싶은 데로 호출할 수도 있다.  
(Build 메서드가 이런 명시적인 메서드 역할을 한다.)  
즉, Pet 객체의 실제 생성자를 호출해서 실제 Pet 객체를 반환한다.  
생성자는 이제 final 키워드를 뺀 private으로 선언할 수 있다.  
  
  
  
## 08 자바 기본  
### 자바에서 객체란 무엇인가?  
객체는 변수들의 컬렉션으로 정의할 수 있다. 간단하거나 복잡한 개체(entity)와 개체들에 관련된 연산을 제공하는 메서드들의 모음을 나타내기 때문이다.  
따라서 객체에는 상태와 행위가 있다.  

변수들은 null로 설정될 수 있으며 메서드 또한 null을 반환할 수 있으나, Null 참조에 대한 메서드를 호출할 수는 없다.  

원시타입의 경우``(예를들어)int i = 42; int j = i;`` 메모리의 다른 위치에 같은 값을 할당하지만,  
``List myList = new ArrayList(20);`` 구문으로 생성된 객체를 변수에 할당할 때 myList는 할당된 메모리 위치를 가리킨다.  
즉, 한 인스턴스에 변경이 생기면 다른 인스턴스가 접근했을 때 영향을 미치게 된다는 뜻이다.  
  
  
### final 키워드는 객체 참조에 어떤 영향을 미치는가?  
객체에 선언하는 final 키워드는 원시 타입에 선언하는 final 키워드와 동일한 역할을 한다.  
즉, 변수 정의에서 지정된 값처럼 일단 할당이 되고 나면 메모리 위치가 변경되지 않는다.  
단, 객체 참조는 변경할 수 없어도 객체 내부의 값들은 개별 값들이 final이 아니라면 변경할 수 있다.  
```  
@Test  
public void finalReferenceChanges() {  
    final int i = 42;  
    // i = 43; //컴파일 에러  
    
    final List<String> list = new ArrayList<>(20);  
    // list = new ArrayList(50); // 컴파일 에러  
    assertEquals(0, list.size());  
    
    list.add("adding a newvalue into my list");  
    assertEquals(1, list.size());  
    
    list.clear();  
    assertEquals(0, list.size());  
}  
```    
  
  
### 객체의 가시성 수정자는 어떻게 작동하는가?  
private 멤버 변수는 오직 해당 클레스에서만 사용할 수 있다.(하위 클래스에서도 사용할 수 없다.)  
오직 해당 타입만 필요하다고 간주한다.  

일반적인 오해는 private으로 선언한 변수는 해당 인스턴스에만 접근할 수 있다고 생각하는 것이다.  
실제로 같은 타입의 다른 모든 인스턴스가 private 멤버 변수에 접근할 수 있다.  
보통은 타입이 같은지 확인할 때 다른 인스턴스의 private 멤버 변수에 접근하며,  
IDE 대부분은 변수에 접근할 때 필요한 올바른 hashcode와 equals 메서드를 만드는 데 도움을 준다.  
  
  
  
## 10 자바 가상머신 이해하기  
### 메모리는 어떻게 할당하는가?  
new 키워드는 자바 힙 영역에 메모리를 할당 한다. 힙은 애플리케이션 영역에 접근할 수 있는 메인 영역이다.  
객체를 할당할 때 이용할 수 있는 메모리가 충분치 않으면 JVM(자바 가상머신)은 가비지 컬렉션을 이용해 힙에서 메모리를 재사용하려고 시도한다.  
그래도 충분한 메모리 영역을 확보할 수 없다면 OutOfMemoryError가 발생하며 JVM이 종료된다.  

힙은 제너레이션이라는 몇 가지 영역으로 구분된다. 가비지 컬렉션에서 객체가 수집 대상에서 제외된다면 다른 제너레이션으로 옮겨진다.  
예를 들어 older제너레이션은 가비지 컬렉션에서 자주 수집하지 않는 객체가 저장되어 있다.  
이미 오랫동안 제거되지 않았음이 증명된 것이므로 가비지 컬렉션에서 수집할 가능성이 낮다.  
  
  
### 가비지 컬렉션이란 무엇인가?  
가비지 컬렉션은 기존에 할당된 메모리를 재사용하는 메커니즘으로, 나중에 메모리를 할당할 때 재사용할 수 있다.  
대부분의 프로그래밍 언어는 가비지 컬렉션을 자동으로 실행한다.  
  
new 키워드는 자바 힙 영역에 메모리를 할당한다. 힙은 애플리케이션 영역에 접근할 수 있는 메모리의 메인 영역이다. 객체를 할당할 때 이용할 수 있는 메모리가 충분하지 않으면 JVM은 가비지 컬렉션을 이용해 힙에서 메모리를 재사용하려고 시도한다. 그래도 충분한 메모리 영역을 확보할 수 없다면 OutOfMemoryError가 발생하며 JVM이 종료된다.  
  
힙은 제너레이션이라는 몇 가지 영역으로 구분된다. 가비지 컬렉션에서 객체가 수집 대상에서 제외된다면 다른 제너레이션으로 옮겨진다. 예를 들어 older제너레이션은 가비지 컬렉션에서 자주 수집하지 않는 객체가 저장되어 있다. 이미 오랫동안 제거되지 않았음이 증명된 것이므로 가비지 컬렉션에서 수집할 가능성이 낮다.  
  
가비지 컬렉션 알고리즘은 몇가지가 있는데, 모든 작동 중인 코드에서 더 이상 참조하지 않는 메모리를 찾은 후 메모리를 할당할 때 이용할 수 있도록 반환한다는 공통의 목적이 있다.  
자바의 전통적인 가비지 컬렉션은 mark-and-sweep 방식이다.  
실행 중인 코드에서 참조하는 객체는 live로 표시되며 해당 객체에서 참조하는 것들 역시 확인해서 live로 표시한다. 이는 현재 동작하는 객체의 모든 경로가 확인될 때까지 계속된다.  
이 과정이 끝나면 힙에 있는 각 객체들을 찾아다니며 live로 표시되지 않은 메모리 위치에 메모리를 할당할 수 있게 만든다.  
이 과정이 진행되는 동안에는 메모리를 재배치하려고 JVM의 모든 스레드가 정지되는데, 이를 stop-the-world라고 한다.  

결국 가비지 컬렉션은 다른 제너레이션으로의 이동과 가능한 한 많은 여유 공간을 남겨두려는 목적으로 메모리에서 객체들을 옮기고 자주 접근되는 객체들을 묶어두는 등의 다른 연산을 수행한다.  
이것을 컴패션이라고 하며, 컴패션은 live로 표시한 객체들을 다른 물리적인 메모리 위치로 옮김으로서 JVM이 stop-the-wold인 동안 메모리 공간을 확보한다.  
  
  
  
## 14 HTTP와 REST 이용하기  
HTTP는 인터넷을 통해 데이터를 요청하고 받기 위한 주된 방법 중 하나다. HTTP는 월드 와이드 웹을 통해 소통하는 데 사용된다. 아파치의 HTTPD, 마이크로소프트의 IIS, 톰캣 같은 HTTP 서버는 체계적으로 들어오는 요청을 수신해서 적절한 응답을 할 수 있도록 구성되어 있다.  
  
HTTP 프로토콜이 어떻게 작동하는지를 이해할 수 있는 좋은 방법은 웹 브라우저가 아닌, 최신 운영체제 대부분에 제공되는 텔넷 같은 애플리케이션을 이용해서 HTTP 요청을 수행해보는 것이다.  
예를 들어 위키백과 같은 사이트에 요청을 보내기 위해 80 포트로 텔넷 연결을 해보면,  
```  
>telnet en.enwikipedia.org 80  
Trying 91.198.174.225 ...  
Connected to wikipedia-lb.esams.wikimedia.org.  
Escape character is '^]'.  
```  
커맨드 프롬프트는 비어 있는 새로운 행에 있게 된다. 요청을 처리하는 서버는 이제 특정 페이지에 대한 요청을 만들기 위해 기다린다.  
새 행에 GET / HTTP/1.1을 입력하면 텔렉 세션은 특정 HTML 코드에 따르는 HTTP 헤더들의 집합에 응답한 후 연결을 종료하고 커맨드 라인으로 돌아온다.  
(GET 메서드를 이용하고 '/' 페이지를 얻고 '1.1' 버전의 HTTP 프로토콜을 사용하라는 세 가지 핵심 명령을 통해 서버를 구성한다. 이 예제는 HTTP 헤더를 서버에 보내지 않는다.)  
HTML 코드는 HTTP 요청에 응답으로 보낼 수 있는 유일한 데이터가 아니다. 순수한 텍스트나 바이너리 데이터를 받을 수도 있으며, 콘텐츠 형식은 일반적으로 Content-Type 헤더에 들어 있다.  
  
HTTP 메서드는 웹 서버에 요청한 자원을 이용해 무엇을 해야 하는지를 알려주는 명령이다. 보통 요청된 자원을 찾도록 서버에게 알려주고 해당 자원을 수정 없이 클라이언트에게 제공한다.   웹 브라우저에서 웹 페이지를 요청할 때 사용하는 방법이기도 하다.  
서버가 구현하는 일반 메서드들은 GET, POST, PUT, DELETE, HEAD 등이며 GET과 HEAD는 서버 구현에 꼭 필요한 메서드다. 또한, HTTP 명세는 OPTIONS 메서드를 구현하라고 말한다. 이 메서드는 클라이언트가 이용할 수 있는 다른 HTTP 메서드가 어떤 것이 있는지 알 수 있는 방법이다.  
  
자바 라이브러리의 표준 클래스를 이용하는 것보다 더 좋은 방법은 전용 자바 HTTP 클라이언트 라이브러리를 사용하는 것이다. 인기 있는 라이브러리로는 아파치의 HttpClient가 있다.   장점은 부가 기능을 사용할 수 있다. 예를 들어 프록시를 통해 HTTP 요청을 실행할 때 HttpClient 라이브러리에서는 AuthenticationStrategy 인터페이스를 구현해서 간단히 속성을 붙일 수 있다. 이러면 매 요청 기반으로 프록시가 필요한지 지정할 수 있다. 쿠키도 CookieStore 객체를 DefaultHttpClient 객체에 붙여서 사용할 수 있다.  
  
Representational State Transfer 또는 줄여서 REST라고 부르는 이 규격은 시스템 사이에 원격 API를 제공하는 HTTP를 이용하는 스타일이다. 이용하는 목적 중 하나는 이미 널리 퍼져 있는 HTTP 프로토콜을 활용해서 클라이언트와 서버를 어떻게 구현할 지 신경 쓰지 않고 시스템과 디바이스가 손쉽게 통신할 수 있게 하는 것이다.  
REST URI는 단일 자원 혹은 여러 가지 자원의 묶음을 가리킨다. REST 서비스의 또 다른 중요한 기능 하나는 멱등성의 개념이다. REST 서비스의 PUT, DELETE, GET 요청은 여러 번 실행해도 결과가 달라지지 않아야 하며, REST 호출은 여러 개의 요청이 있더라도 한 번만 요청한 것 같은 효과를 내야한다. 멱등성의 개념을 포함하는 API의 장점은 클라이언트가 요청이 성공적이었는지 확신할 수 없을 때 요청을 다시 보내도 된다는 것이다.  
  
  
  
## 15 직렬화  
객체 직렬화(serialization)는 JVM에서 자바 객체를 '내보내는' 간단한 방법이다. 직렬화된 객체는 디스크에 기록할 수도 있고, 네트워크가 아닌 다른 I/O 인터페이스에 기록할 수도 있다.  
직렬화된 데이터를 파일 시스템에 읽고 쓰는 데 FileInputStream과 FileOutputStream 클래스를 이용할 수 있고, InputStream과 OutputStream 클래스로 대체할 수도 있다. HTTP 서버에서 데이터를 이용하고 싶으면 HttpServletRequest와 HttpServletResponse 인터페이스를 이용하면 된다.  
  
스트림에 데이터를 기록할 때 직렬화하고 싶지 않은 필드가 직렬화할 수 있는 객체 안에 있으면, 해당 필드 선언 위에 transient 키워드를 적용할 수 있다. transient를 적용한 필드는 역직렬화될 때, null을 반환한다.  
transient를 적용한 필드를 생성해서 사용하는 경우로, private 필드를 캐시로 사용할 때 역직렬화하는 작업이 있다. 이 작업을 통해 캐시를 간단히 재생성할 수 있다. 또는 다른 필드에서 생성된 필드처럼 역직렬화한 후에 데이터가 재생성될때도 transient를 적용할 수 있다. transient를 적용한 필드에는 비밀이 유지되어야 하거나 민감한 정보가 담긴 데이터를 둘 수 있다.  
  
JSON(JavaScript Object Notation)은 XML과 비슷한 직렬화 접근 방법이다. JSON은 사람이 읽을 수 있는 접근 방법을 사용하며 다양한 언어를 통해 파싱되고 처리될 수 있다. 자바스크립트의 일부에서 유래되었고, XML보다 구문이 적어 부담이 덜하다는 이유로 다른 언어용 라이브러리에서 많이 채택했다.  
JSON 문서는 느슨하게 정의되어 있고, 좋은 구조를 갖추고 있다. 문자열은 따옴표로 둘러싸인 텍스트고 실수와 정수 사이에는 차이가 없다. 리스트는 대괄호로 둘러싸여 콤마로 구분된 목록이다. 객체는 중괄호로 둘러싸인 키-값 쌍 컬렉션이며, 키들은 항상 문자열이다. 값은 null을 포함한 모든 타입을 사용할 수 있다.  
자바 애플리케이션은 JSON 파싱과 처리를 구현할 때 Jackson 이라는 라이브러리를 사용한다. 도메인 객체에서 JSON을 생성하는 데 사용할 수 있다.  
  
  
  
## 17 하이버네이트  
하이버네이트는 자바 객체와 데이터베이스 테이블 사이의 매핑을 관리하려고 만들어진 도구다. 보통 ORM(Object Relational Mapping)이라고 한다. 하이버네이트는 개체(entity)들의 도메인 객체가 있어야 한다. 이 클래스들은 단순한 POJO(Plain Old Java Obejct)고, 각 객체는 관련 데이터베이스 테이블과 간단하게 연결된다.
(POJO: 이상적으로 POJO는 자바 언어 사양 외에 어떠한 제한에도 묶이지 않은 자바 오브젝트라고 할 수 있다.)  
  
하이버네이트를 위한 객체를 만들 때는 생성자를 이용하므로, 인자가 없는 기본 생성자를 포함해야한다. 클래스의 필드들은 final 키워드로 선언해서는 안된다.  
  
클래스와 테이블 사이의 매핑을 명시하기 위한 xml 파일용 이름을 짓는 규칙은 <entity>.hbm.xml이다. ex) Person.hbm.xml  
  
데이터베이스와 연결 설정이 완료되면, 테이블의 행을 Person 객체로 가져와서 사용하며, 일단 Person 객체가 하이버네이트를 통해 만들어지면, 하이버네이트나 데이터베이스에 의존성이 없으며 일반 POJO가 된다는 것을 알 수 있다.  
  
하이버네이트를 라이브러리보다 프레임워크로 다뤄야 한다. 애플리케이션에 하이버네이트 JAR을 넣고 기존에 만들어진 데이터베이스 스키마와 애플리케이션과 잘 동작하기를 기대하지 말고, 하이버네이트가 동작하는 방식으로 애플리케이션을 개발해야 한다.  
  
  
  
## 19 빌드 도구 이용해 개발하기  
### 메이븐이란 무엇인가?  
프로젝트의 자원을 모두 하나로 합치는 데 집중하는 애플리케이션인 메이븐과 앤트가 있다. 자바 프로젝트를 위해 가장 많이 사용되는 빌드 도구다.  
메이븐은 프로젝트 전체를 포괄하는 빌드 도구로, 자바 프로젝트를 컴파일, 테스트, 배포하는 데 사용된다.  
설정을 통해 만든 규칙을 따르도록 설계되어 있다.  
대부분의 자바 애플리케이션용 빌드는 매우 비슷한 방법으로 정의될 수 있으며, 비슷한 구조로 소스 코드를 작성하면 메이븐은 필요한 자원들을 어디서 찾아야 하는지 파악해 여러 가지 빌드 작업을 수행한다.  
  
메이븐에는 대부분의 프로젝트 설정이 기본으로 내장되어 있어 애플리케이션이 WAR(Web Archive)나 JAR 파일로 배포될 것이다.  
메이븐은 이 작업들을 어떻게 빌드해야 하는지에 대한 정의를 갖고 있다.  

메이븐의 플러그인 시스템은 빌드에 특정한 연산을 더 추가할 수 있게 해준다.  
의존성 설정과 비슷하게 이 플러그인들은 원격으로 제공되며, 메이븐은 빌드할 때 이들을 찾을 수 있다.  
또한 플러그인이 제공하는 연산이 무엇이든 실행할 수 있다.  
일반적인 플러그인의 예는 ``maven-jetty-plugin``인데, 이는 현재 빌드를 웹 애플리케이션 형태로 실행한다.  
이 플러그인은 프로젝트가 web.xml 파일을 ``src/main/webapp/WEB-INF`` 디렉터리에 두는 관습을 따른다는 가정 아래 적합한 web.xml 파일을 찾는다.  
이러한 역할을 수행하는 또다른 플러그인은 ``maven-release-plugin``이며, 출시 빌드용으로 코드를 나누고 애플리케이션의 버전 번호를 변경하기 위해 서브버전이나 Git 같은 소스 버전 관리 도구와 연계해서 복잡한 작업을 수행하고, 다음 개발주기를 준비한다.  
  
  
### 메이븐 빌드의 생명주기는 무엇인가?  
메이븐 빌드는 생명주기라는 일련의 상태로 구성되며 각 상태는 특정 골에 따라 구분된다.  
(골: 실행하기 위한 작업의 특정 단위)  
각 상태는 이전 상태에 의존하며 어떤 이유에서든 특정 골을 통한 작업에 문제가 발생하면 전체 빌드가 실패할 수밖에 없다.  
-기본상태  
1. clean  
2. validate -> compile -> test -> package -> install  
3. deploy  
  
어떤 빌드 결과물은 프로젝트 루트의 ``target``이라는 디렉터리에 저장된다. clean상태의 골은 이 ``target`` 디렉터리를 지워서 이전에 빌드된 파일들을 없앤다.  
이는 mvn clean 같은 빌드 상태를 명시해서 초기화하거나 항상 실행되도록 POM(Project Object Model)에 정의하지 않으면 다음 상태가 되기 전에는 실행하지 않는다.  
  
validate 상태는 메이븐의 빌드 파일용 XML 사양을 따르는 올바른 pom.xml 파일인지 확인한다.  
compile 상태는 모든 정의된 의존성들을 가져오고, 코드를 컴파일하고, 모든 클래스 파일을 ``target/classes`` 디렉터리에 빌드한다.  
test 상태는 디렉터리에 있는 클래스들을 컴파일하고 디렉터리에 있는 모든 단위 테스트 또는 통합 테스트용 테스트 코드를 실행한다.  
package 상태는 WAR나 JAR파일 같은 결과물을 생성한다. 이 파일은 target 디렉터리의 루트에 저장된다.  
install 단계는 빌드된 결과물을 내부 메이븐 저장소로 보낸다. 대개 ``$HOME/.m2/repository``디렉터리에 위치한다.  
  
마지막 단계는 deploy 단계로, 마무리된 결과물을 배포하기 위한 장소가 어딘지 정확히 정의하는 추가 설정이 좀 더 필요하다.  
  
  
끝  