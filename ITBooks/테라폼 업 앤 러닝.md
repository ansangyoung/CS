# Terraform Up & Running  
## 테라폼 업 앤 러닝  
## 예브게니 브릭만 지음 | 김문주 옮김  

### 역자 서문  
API로 정의되어 호출만 하면 사용할 수 있는 부분도 코드로 정의하여 필요한 인프라를 만들고, 수정하고, 삭제할 수 있는 세상이 되었다.  
이렇게 인프라를 코드로 관리하는 것을 '코드형 인프라(Infrastructure as Code, IaC)'라고 한다.  

### 온프레미스(On-premise) 환경  
소프트웨어 등 솔루션을 클라우드 같이 원격 환경이 아닌 자체적으로 보유한 전산실 서버에 직접 설치해 운영하는 방식.  

### 프로비저닝  
사용자의 요구에 맞게 시스템 자원을 할당, 배치, 배포해 두었다가 필요 시 시스템을 즉시 사용할 수 있는 상태로 미리 준비해 두는 것.  


### 01 왜 테라폼인가?  
소프트웨어는 진짜 사용자에게 전달될 때까지 완성되는 것이 아니다.  
앞으로 다음과 같은 주제를 다룬다.  
-데브옵스의 등장  
-코드형 인프라란?  
-코드형 인프라의 장점  
-테라폼의 작동 방식  
-테라폼과 다른 코드형 인프라 도구 비교  


### 01-1 데브옵스의 등장  
예전에는 역할별로 팀이 나뉘어 있었다. 
-소프트웨어를 개발하는 팀은 개발팀(Devs)  
-하드웨어를 관리하는 팀은 운영팀(Ops)  

오늘날의 조직은 데이터 센터를 직접 운영하는 것 대신에 아마존 웹서비스(AWS), 마이크로소프트 애저(Azure), 구글 클라우드 플랫폼(GCP)같은 클라우드 서비스를 사용하기 시작했다. 

수많은 운영팀들이 하드웨어에 많은 돈과 노력을 투자하는 대신 셰프(Chef), 퍼핏(Puppet), 테라폼(Terraform), 도커(Docker)와 같은 도구를 사용하여 소프트웨어 작업에 더 많은 시간을 들이고 있다.   (시스템관리자가 서버를 설치하고 네트워크 케이블 설치 작업을 하는 대신에 코드를 작성한다.)  
결과적으로 이제는 개발팀과 운영팀 모두 소프트웨어 작업에 대부분의 시간을 소비하며 두 팀의 구분이 모호해지며, 보다 밀접하게 작업해야 한다는 것이 분명한 것이다. 

#### 데브옵스란  
데브옵스는 팀이나 직책 또는 특정 기술이 아니라 일련의 프로세스, 아이디어, 테크닉이다.  
즉, 소프트웨어를 효율적으로 전달하는 프로세스이다.  

데브옵스에는 4가지 핵심 가치가 존재하는데, 문화(Culture), 자동화(Automation), 측정(Measurement), 공유(Sharing)이다.  
줄여서 CAMS라고도 하며, 이 책은 데브옵스 전반을 개괄하는 대신 배포 자동화에 초점을 맞추어 이야기한다.  



### 01-2 코드형 인프라란?  
웹 페이지를 클릭하거나 셸 명령을 수동으로 실행하는 방법 대신 코드를 통해 인프라를 관리할 수 있는데, 이를 '코드형 인프라'라고 한다.  
즉, 코드를 작성 및 실행하여 인프라를 생성, 배포, 수정, 정리하는 것을 말한다.  

이는 서버를 물리적으로 설치하는 등의 하드웨어 측면을 포함하여 운영의 모든 측면을 소프트웨어적으로 생각하는 중대한 사고 전환을 보여준다.  

실제로 데브옵스의 핵심은 서버, 데이터베이스, 네트워크, 로그 파일, 애플리케이션 구성, 문서, 자동화된 테스트, 배포 프로세스 등 거의 모든 것을 코드로 관리할 수 있다는 것이다.  


코드형 인프라 도구에는 다섯 가지 범주가 있다.  
1. 애드혹 스크립트  
2. 구성 관리 도구  
3. 서버 템플릿 도구  
4. 오케스트레이션 도구  
5. 프로비전 도구  


### 01-2.1 애드혹 스크립트  
자동화하는 가장 간단한 방법은 애드혹 스크립트(ad hoc script)를 사용하는 것이다.  
수행할 작업을 단계별로 나누고 배시, 루비, 파이썬 등 선호하는 언어를 사용하여 각 단계를 코드로 정의하고, 작성된 스크립트를 서버에서 수동으로 실행하는 것이다.  
하지만 이는 코드를 직접 작성하여 수동으로 작업해야 한다는 것을 의미한다.  
즉, 범용 프로그래밍 언어를 사용하면 사용자가 매번 수동으로 맞춤 코드를 작성해야 한다.  

그러나 코드형 인프라를 위해 특수 제작된 도구를 사용하면 이런 복잡한 작업을 간결한 API로 수행할 수 있다.  
또한 코드형 인프라용으로 설계된 도구를 사용하면 대체로 코드에 정해진 구조가 적용된다.  

따라서 애드혹 스크립트는 소규모 일회성 작업에는 적합하지만,  
모든 인프라를 코드로 관리하려면 작업 목적에 맞게 설계된 코드형 인프라 도구를 사용해야 한다.  


### 01-2.2 구성 관리 도구  
셰프, 퍼핏, 앤서블, 솔트스택 등은 모두 구성 관리 도구로써 대상 서버에 소프트웨어를 설치하고 관리하도록 설계되어 있다.  
앤서블과 같은 도구를 사용하면 애드혹 스크립트를 사용할 때와 다른 여러 가지 장점이 있다.  

1. 코딩규칙  
앤서블은 문서화, 파일 레이아웃, 명확하게 이름 붙여진 매개 변수, 시크릿 관리 등을 포함하는 일관되고 예측 가능한 구조를 제공한다.   
개발자마다 다양한 방식으로 애드혹 스크립트를 작성할 수 있지만, 이러한 구성 관리 도구에는 코딩 규칙이 포함되어 있어 코드를 쉽게 탐색할 수 있게 해준다.  

2. 멱등성  
실행 횟수에 관계없이 올바르게 동작하는 코드를 '멱등성을 가진 코드'라고 한다.  
앤서블이 제공하는 대부분의 기능은 기본적으로 멱등성을 가진다.  
예를 들어, '앤서블 롤'은 설정 파일을 사용하여 아파치가 설치되지 않았을 경우에만 설치하고,  
아파치 웹 서버가 동작하지 않는 경우에만 동작하도록 한다.  

3. 분산형 구조  
애드혹 스크립트는 단일 로컬 머신에서만 실행되도록 설계되었지만,  
앤서블과 같은 구성 관리 도구는 원격의 수많은 서버를 관리하기 위해 특별히 설계된 것이다.  


### 01-2.3 서버 템플릿 도구  
구성 관리 도구의 대안으로 최근에 도커, 패커(Packer), 베이그런트(Vagrant)와 같은 서버 템플릿 도구도 인기가 높아지고 있다. 
서버 템플릿 도구는 운영 체제, 소프트웨어, 파일 및 기타 필요한 모든 내용을 포함하고 있는 '스냅숏'으로 이미지를 생성한다. 
그런 다음 앤서블과 같은 코드형 인프라 도구를 사용하여 모든 서버에 이미지를 설치할 수 있다.  

서버 템플릿 도구들은 각각의 목적이 약간씩 다르다.  
패커는 일반적으로 프로덕션 서버에서 직접 실행하는 이미지를 생성하는 데 사용된다.  
베이그런트는 일반적으로 macOS나 Windows 랩톱에서 실행되는 버추얼박스 이미지와 같이 개발 컴퓨터에서 실행되는 이미지를 만드는 데 사용된다.  
도커는 일반적으로 개별 응용 프로그램의 이미지를 만드는데 사용된다.  

서버 템플릿은 불변 인프라로 전환하는 데 있어 핵심적인 구성 요소이다.  
한번 배포된 서버는 다시 변경되지 않는다.  
(서버를 변경해야 하는 경우 서버 템플릿에서 새 이미지를 만들어 새 서버를 배포해야 한다.)  
서버는 절대 변하지 않기 때문에 배포된 부분을 관리하기 쉬워진다.  


### 01-2.4 오케스트레이션 도구  
실제 사용 환경에서는 다음을 수행할 방법이 필요하다.  
1. VM과 컨테이너를 하드웨어에 효율적으로 배포하기  
2. 롤링 배포, 블루-그린(blue-green)배포, 카나리(canary)배포 전략을 사용하여 기존의 VM이나 컨테이너를효율적으로 업데이트하거나 롤백하기  
3. VM과 컨테이너의 상태를 모니터링하고 비정상적인 부분을 자동으로 대체하기(자동 복구)  
4. 발생하는 트래픽에 따라 VM과 컨테이너의 수를 늘리거나 줄이기(자동 확장)  
5. VM과 컨테이너의 트래픽을 분산하기(로드 밸런싱)  
6. 서로 다른 네트워크에 있더라도 VM과 컨테이너가 서로 식별하고 통신할 수 있게 하기(서비스 검색)  

이 작업들을 처리하기 위해  
쿠버네티스, 마라톤/메소드, 아마존 엘라스틱 컨테이너 서비스, 도커 스웜, 그리고 노마드 같은 오케스트레이션 도구가 필요하다.  

예를 들어 쿠버네티스를 사용하면 도커 컨테이너를 어떻게 관리할지를 코드로 정의할 수 있다.  
우선 쿠버네티스 클러스터, 즉 쿠버네티스가 도커 컨테이너를 관리하고 작동하기 위해 사용하는 서버들의 그룹을 배포한다.  
쿠버네티스를 위한 아마존 엘라스틱 컨테이너 서비스(Amazon EKS), 구글 쿠버네티스 엔진(GKE), 애저 쿠버네티스 서비스(AKS) 같은  
주요 클라우드 공급자들은 시스템 자체에서 쿠버네티스 클러스트를 지원한다.  


### 01-2.5 프로비전 도구  
구성 관리, 서버 템플릿 및 오케스트레이션 도구가 각 서버에서 실행되는 코드를 정의한다면,  
테라폼, 클라우드포메이션, 오픈스택 히트와 같은 프로비전 도구는 서버 자체를 생성한다.  

사실상 프로비전 도구를 사용하면 서버만 생성하는 것이 아니라  
데이터베이스, 캐시, 로드 밸런서, 큐, 모니터링, 서브넷 구성, 방화벽 설정, 라우팅 규칙 설정, SSL 인증서 등  
인프라에 관한 거의 모든 부분을 프로비저닝할 수 있다.  



### 01-3 코드형 인프라의 장점  
수동으로 코드를 변환하지 않아도 되므로 소프트웨어를 효율적으로 배포할 수 있다.  
인프라가 코드로 정의되면 다음과 같은 배포 프로세스를 극적으로 개선할 수 있다.  
1. 자급식 배포(Self-service)  
-인프라를 코들 정의하면 전체 배포 프로세스를 자동화할 수 있으며, 개발자는 필요할 때마다 자체적으로 배포를 진행할 수 있다.  

2. 속도와 안정성(Speed and safety)  
-배포 프로세스를 자동화하면 사람이 진행하는 것보다 훨씬 빠르게 컴퓨터가 배포를 진행할 수 있다.  
자동화된 프로세스는 일관되고 반복 가능하며, 수동으로 진행했을 때보다 오류가 적게 발생하기 때문에 더 안전하다.  

3. 문서화(Documentation)  
-시스템 관리자 조직만 인프라에 관한 정보를 독점하는 것이 아니라 누구나 읽을 수 있는 소스 파일로 인프라 상태를 나타낼 수 있다.  
(문서 역할을 해서 조직의 모든 사람이 인프라 구조를 이해하고 업무를 볼 수 있도록 해준다.)  

4. 버전 관리(Version control)  
-인프라의 변경 내용이 모두 기록된 코드형 인프라 소스 파일을 저장할 수 있으므로 버전을 쉽게 관리할 수 있다.  
(디버깅을 돕는 강력한 도구이다.)  

5. 유효성 검증(Validation)  
-인프라 상태가 코드로 정의되어 있으면 코드가 변경될 때마다 검증을 수행하고 일련의 자동화된 테스트를 실행할 수 있다.  
정적 분석(static analysis) 프로그램에 코드를 전달하여 오류 발생 위험을 줄일 수 있다.  

6. 재사용성 (Reuse) 
-인프라를 재사용 가능한 모듈로 패키징할 수 있으므로 모든 제품을 매번 처음부터 배포하는 대신 문서화되고 검증된 모듈로 일관되게 배포할 수 있다.  

7. 행복(Happiness)  
-코드형 인프라를 사용해야 하는 또 다른 중요한 이유는 바로 코드형 인프라를 사용했을 때 얻을 수 있는 행복 때문이다.  
코드형 인프라는 개발자가 코드 개발 작업에 더 집중할 수 있도록 대안을 제시한다.  
	
	

### 01-4 테라폼의 작동 방식  
테라폼은 해시코드사가 Go 언어로 개발한 오픈 소스 도구이다.  
운영 체제마다 바이너리 파일이 존재하는데 Go 코드는 하나의 바이너리 파일로 컴파일되며, ``terraform``이라는명령어로 실행할 수 있다.  

이 바이너리를 사용해서 랩톱이나 빌드 서버 또는 다른 어떤 컴퓨터에서든 인프라를 배포할 수 있으며, 이를 위해 추가 인프라를 생성할 필요가 없다.  
정확하게는 ``terraform``바이너리가 AWS, 애저, 구글 클라우드, 디지털오션, 오픈스택 등의 공급자를 대신해 API를 호출하여 리소스를 생성한다.  

테라폼은 생성하려는 인프라 정보가 담겨 있는 텍스트로 이루어진 테라폼 구성 파일을 생성하여 API를 호출한다.  
과정으로는  
1. 테라폼 구성 파일에 서버, 데이터베이스, 로드 밸런서, 네트워크 토폴로지 등 전체 인프라를 정의하고 해당 파일의 버전을 관리할 수 있다.  
2. 그런 다음 ``terraform apply``같은 특정 명령어를 사용하여 인프라를 배포할 수 있다.  
3. ``terraform``바이너리는 사용자가 구성한 코드를 파싱하고 코드에 지정된 클라우드 공급자에 대한 일련의 API호출로 변환한다.  
4. 그런 다음 최대한 효율적으로 API를 호출한다.  



### 01-5 테라폼과 다른 코드형 인프라 도구 비교  
코드형 인프라 도구를 선택할 때 고려해야 하는 주요 절충 사항은 다음과 같다.  
1. 구성관리 VS 프로비저닝  
2. 가변 인프라 VS 불변 인프라  
3. 절차적 언어 VS 선언적 언어  
4. 마스터 서버가 있는가?  
5. 에이전트가 있는가?  
6. 커뮤니티가 크고 활성화되어 있는가?  
7. 성숙한 기술인가, 아니면 최첨단 기술인가?  
8. 여러 도구를 함께 사용할 것인가?  


### 01-5.1 구성관리 VS 프로비저닝  
셰프, 퍼핏, 앤서블, 솔트스택은 구성 관리 도구인 반면  
클라우드포메이션, 테라폼, 오픈스택 히트는 프로비전 도구이다.  

서버 템플릿 도구를 사용하지 않는 경우, 구성 관리 및 프로비전 도구를 함께 사용하는 것이 좋다.  
예를 들어 테라폼을 사용하여 서버를 프로비저닝하고, 셰프를 실행하여 각 서버를 구성할 수 있다.  


### 01-5.2 가변 인프라 VS 불변 인프라  
셰프, 퍼핏, 앤서블, 솔트스택과 가은 구성 관리 도구는 일반적으로 가변 인프라 패러다임을 사용한다.  
예를 들어 셰플에 새 버전의 OpenSSL을 설치하도록 지시하면  
기존 서버에서 소프트웨어 업데이트가 실행되고 변경 사항이 적용된다.  

시간이 지나면서 점점 더 많은 업데이트를 적용하는데 그때마다 각 서버는 고유한 변경 기록을 작성한다.  
결과적으로 매 서버가 약간씩 다를 수 있으므로 진단 및 재현이 어려운 미묘한 구성에 관한 버그가 발행할 수 있다.  
(이는 서버를 수동으로 관리할 때 발생하는 것과 동일한 구성 드리프트 문제이다.)  

테라폼과 같은 프로비전 도구를 사용하여 도커 또는 패커에서 생성한 머신 이미지를 배포하는 경우 대부분의 '변경'은 완전히 '새로운 서버'를 배포하는 것과 같다.  
예를 들어 새 버전의 OpenSSL을 배포하는 경우 패커로 새 버전의 OpenSSL이 포함된 새 이미지를 작성하여 배포한 다음 이전 서버는 종료한다.  
모든 배포는 새로운 서버에서 변경 불가능한 이미지를 사용한다.  
이 방식은 구성 드리프트 버그를 줄이고 각 서버에서 어떤 소프트웨어가 실행 중인지 정확하게 알 수 있게 한다.  

이 같은 접근 방식에는 단점이 있는데, 사소한 변경을 할 때조차 서버 템플릿에서 이미지를 재구성하고 모든 서버를 재배치하기 때문에 시간이 오래 걸린다.  
더구나 '불변성'은 실제로 이미지를 실행하는 순간까지만 지속된다.  
즉, 서버가 가동되어 실행되기 시작하면 하드 드라이브가 변경되므로 어느 정도의 구성 드리프트는 발생할 수 밖에 없다.  
(빈번하게 배포하는 경우 이런 문제를 완화할 수 있다.)  


구성 관리 도구도 변경 불가능한 배포를 수행할 수는 있지만,  
이는 적절한 접근 방법이 아니므로 프로비전 도구를 사용하는 것이 적절한 접근 방법이다.  


### 01-5.3 절차적 언어 VS 선언적 언어  
셰프와 앤서블은 원하는 최종 상태를 달성하는 방법을 단계별로 지정하는 절차적 스타일 코드를 권장한다.  
테라폼, 클라우드포메이션, 솔트스택, 퍼핏, 오픈스택 히트는 모두 원하는 최종 상태를 지정하는 선언적 방식의 코드를 권장한다.  
선언적 언어란 구현하려는 최종 상태를 지정하는 코드를 말하며,  
이때 코드형 인프라 자체는 그러한 최종 상태를 어떻게 구현할 것인지 계산하는 역할을 한다.  

절차적 방식을 사용하는 코드형 인프라 도구에는 2가지 주요한 문제가 있다.  
1. 절차적 코드는 인프라의 마지막 상태 정보를 기록하고 있지 않다.  
2. 절차적 코드는 재사용 가능성을 제한한다.  

테라폼의 선언적 방식을 사용하면 코드는 항상 인프라의 최신 상태를 나타낸다.  
현재 배포되어 있는 인프라의 내용과 구성을 한눈에 확인할 수 있고,  
현재 상태를 수동으로 설명할 필요가 없으므로 재사용 가능한 코드를 작성하기 쉽다.  
(간소하고 이해하기 쉽다.)  

표현력이 제한되어 있다는 단점이 있지만, 입력 변수, 출력 변수, 모듈, count, 3항 연산자 및 내장 함수 기능 등을 제공하므로  
구성이 자유로운 모듈식 코드를 작성할 수 있다.  


### 01-5.4 마스터 서버 유무  
셰프, 퍼핏, 솔트스택은 인프라 상태를 저장하고 업데이트를 배포하기 위해 마스터 서버를 실행한다.  
인프라를 업데이트하려면 명렬줄(command-line) 도구와 같은 클라이언트를 사용하여 마스터 서버에 새 명령을 실행한다.  
그러면 마스터 서버가 업데이트 내용을 모든 서버로 푸시하거나,  
서버들이 주기적으로 마스터 서버에서 최신 업데이트를 가져온다.  

#### 마스터 서버의 장점  
1. 마스터 서버는 인프라의 상태를 살펴보고 관리할 수 있는 단일한 중앙 저장소 역할을 한다.  
-많은 구성 관리 도구는 마스터 서버에 셰프 콘솔, 퍼핏 엔터프라이즈 콘솔과 같은 웹 인터페이스를 제공하여 상황을 쉽게 확인할 수 있다.  

2. 어떤 마스터 서버는 백그라운드에서 지속적으로 실행되어, 구성의 일관성을 유지한다.  
-누군가 서버를 수동으로 변경하더라도, 마스터 서버는 변경 사항을 되돌려 놓으므로 구성 드리프트 문제가 발생하는 것을 방지할 수 있다.  


#### 마스터 서버의 단점  
1. 추가 인프라 필요  
-마스터를 실행하려면 추가 서버 또는 고가용성 및 확장성을 위해 클러스터링 된 서버가 필요하다.  
2. 유지 관리  
-마스터 서버를 유지, 업그레이드, 백업, 모니터링 및 확장해야 한다.  
3. 보안  
-클라이언트가 마스터 서버와 통신할 방법, 그리고 마스터 서버가 다른 모든 서버와 통신할 방법을 마련해야 한다.  
이는 일반적으로 추가 포트를 열고 추가 인증 시스템을 구성해야 하는데, 이러한 구성은 서버가 공격당할 가능성을 높인다.  


셰프, 퍼핏, 솔트스택은 마스터 서버가 없는 환경에서도 실행할 수 있는 다양한 옵션을 제공한다.  
예를 들어 마스터 서버가 아닌 버전 관리 시스템에서 최신 업데이트를 가져오게 할 수 있다.  
이로써 주기적으로 마스터 서버에서 최신 업데이트를 가져와야 하는 부담을 크게 줄일 수 있다.  

앤서블, 클라우드포메이션, 오픈스택 히트, 테라폼은 기본적으로 마스터가 없는 도구이다.  
정확하게는 일부 서버는 마스터 서버에 의존할 수 있지만, 이미 사용중인 인프라의 일부이며 관리해야 할 추가적인 요소가 아니다.  


### 01-5.5 에이전트 유무  
셰프, 퍼핏, 솔트스택은 모두 구성하려는 서버에  
셰프 클라이언트, 퍼핏 에이전트, 솔트 미니언 등의 에이전트 소프트웨어를 설치해야 한다.  
에이전트는 일반적으로 각 서버의 백그라운드에서 실행되며, 구성 관리 업데이트의 설치를 담당한다.

#### 단점  
1. 부트스트랩  
-부트스트랩은 일회용 명령을 실행하여 클라우드 업체가 제공하는 API로 서버를 할당하고,  
SSH를 통해 해당 서버에 에이전트 소프트웨어를 설치한다.  

2. 유지관리  
-에이전트 소프트웨어가 있는 경우 마스터 소프트웨어와 동기화된 상태를 유지하도록 에이전트 소프트웨어를 정기적으로 업데이트해야 한다.  
또한 에이전트 소프트웨어를 모니터링하여 문제가 있으면 에이전트를 다시 시작해야 한다.  

3. 보안  
-에이전트 소프트웨어가 마스터 서버에서 구성을 가져오는 경우 모든 서버에 아웃바운드 포트를 열어야 한다.  
또한 마스터 서버가 에이전트에 구성을 푸시하면 모든 서버에서 인바운트 포트를 열어줘야 한다.  
두 경우 모두 통신 중인 서버에 에이전트를 어떻게 인증할지 생각해야 하며, 이는 모두 서버가 공격당할 가능성을 높인다.  


셰프, 퍼핏, 솔트스택의 기본적인 구조는 에이전트와 마스터가 포함된 형태이다.  
이 중 셰프는 컴퓨터에서 셰프 클라이언트를 실행하여 셰프 마스터 서버를 실행한다.  
그러면 셰프 클라이언트가 다른 모든 서버에서 실행 중인 셰프 클라이언트와 통신하여 변경 사항을 배포한다.  

앤서블, 클라우드포메이션, 오픈스택 히트, 테라폼은 추가적인 에이전트를 설치할 필요가 없다.  
더 정확하게는 일부는 에이전트를 필요로 하지만, 사용 중인 인프라의 일부로 이미 설치되어 있다.  

예를 들어, AWS, 애저, 구글 클라우드 등의 클라우드 업체는 각각 물리적 서버에 에이전트 소프트웨어를 설치하여 관리 및 인증을 수행한다.  
테라폼은 명령을 실행하면, 클라우드 공급자의 에이전트가 모든 서버에서 명령을 실행한다.  
(클라이언트만 실행하면 AWS와 같은 클라우드 공급자의 API를 사용하여 나머지 모든 것을 처리한다.)    
앤서블을 사용하면 서버는 SSH 데몬을 실행해야 하는데, SSH 데몬은 대부분 서버에서 실행된다.  


### 01-5.6 커뮤니티 규모와 활성화  
기술을 선택할 때 커뮤니티도 중요하게 고려해야 하며,  
대부분의 경우 프로젝트 주변의 생태계가  
기술 자체의 품질보다 사용자 경험에 더 큰 영향을 줄 수있다.  

경향을 파악한다면, 테라폼과 앤서블은 폭발적인 성장을 하고 있다.  
(기여자 수, 별점, 오픈 소스 라이브러리, 스택 오버플로 게시물 수 및 직업의 수가 증가했다.)  


### 01-5.7 성숙한 기술 VS 최첨단 기술  
기술을 선택할 때 고려해야 할 또 다른 주요 요소는 기술의 성숙도이다.  

테라폼은 가장 최근에 나왔기에 여전히 1.0.0 이전의 버전이므로 안정적이지 않고,  
이전 버전과 호환되는 API를 보장하지 않으며,  
대부분 사소한 것들이기는 해도 버그가 존재할 수 있다.  
(가장 큰 약점이다.)  


### 01-5.8 여러 도구를 함께 사용  
실제로 인프라를 구축하기 위해서는 여러 도구를 함께 사용해야 할 수도 있다. 

#### 세 가지 일반적인 코드형 인프라 도구 조합  
1. 프로비저닝과 구성관리  
-테라폼과 앤서블을 함께 사용할 수 있다.  
테라폼을 사용하여 VPCs(Virtual Private Clouds, 가상 프라이빗 클라우드) 서브넷, 라우팅 테이블 같은 네트워크 토폴로지와  
MySQL, 레디스(Redis) 같은 데이터 저장소 그리고 로드 밸런서, 서버 등을 포함한 모든 기본 인프라를 배포한다.  
그런 다음 앤서블을 사용하여 서버에 앱을 배포한다.  

2. 프로미저닝과 서버 템플릿  
테라폼과 패커를 함께 사용할 수 있다.  
패커를 사용하여 앱을 VM 이미지로 패키징한다.  
그런 다음 테라폼을 사용하여 VM 이미지를 배포하고, VPCs, 서브넷, 라우팅 테이블 등 나머지 인프라 네트워크 토폴로지와 MySQL, 레디스 등 데이터 저장소, 로드 밸런서를 배포한다.  

3. 프로비저닝과 서버 템플릿 그리고 오케스트레이션 도구  
테라폼, 패커, 도커 그리고 쿠버네티스를 함꼐 사용할 수 있다.  
패커를 사용하여 도커 및 쿠버네티스가 설치된 VM 이미지를 실행하는 서버, 나머지 인프라와 VPCs, 서브넷, 라우팅 테이블과 같은 네트워크 토폴로지, MySQL, 레디스 같은 데이터 저장소 및 로드 밸런서를 배포한다.  
마지막으로 서버가 구동되면 컨테이너로 된 애플리케이션을 쿠버네티스 같은 오케스트레이션 도구에서 실행한다.  


### 01-6 결론   
코드형 인프라 도구는 다른 구성에서도 사용할 수 있을 만큼 유연하다.  
예를 들어 마스터 서버 없이 셰프를 사용할 수 있고, 솔트를 사용하여 불변 인프라를 구성할 수 있다.  

표 1-4는 테라폼이 완벽하지는 않지만, 모든 기준을 충족시키는 도구에 가장 가깝다는 것을 보여준다.  
  
  
  
## 04 테라폼 모듈로 재사용 가능한 인프라 생성하기  
### 04-5 모듈 주의 사항  
모듈을 만들 때는 다음과 같은 사항을 주의해야한다.  
1. 파일 경로  
2. 인라인 블록  
  
  
### 04-5.1 파일 경로  
file 함수를 사용할 때 파일 경로가 상대 경로여야 한다.  
(다수의 서로 다른 컴퓨터에서 테라폼을 실행할 수 있기 때문이다.)  
  
기본적으로 테라폼은 현재 작업 중인 디렉터리를 기준으로 경로를 해석한다.  
``terraform apply``를 실행하는 디렉터리와 동일한 디렉터리에 있는 테라폼 구성 파일에서 file 함수를 사용하는 것,  
즉 루트 모듈에서 file 함수를 사용하는 것은 가능하지만, 별도의 폴더에 정의된 모듈에서 file 함수를 사용할 수는 없다.  
이 문제를 해결하기 위해 ``path.<TYPE>`` 형태의 경로 참조(path reference) 표현식을 사용할 수 있다.  
  
테라폼은 다음 유형의 경로 참조를 지원한다.  
1. path.module  
-표현식이 정의된 모듈의 파일 시스템 경로를 반환한다.  
  
2. path.root  
-루트 모듈의 파일 시스템 경로를 반환한다.  
  
3. path.cwd  
-현재 작업 중인 디렉터리의 파일 시스템 경로를 반환한다. 
(테라폼을 일반적으로 사용할 때 이것은 path.root와 동일하지만, 테라폼의 일부 기능은 루트 모듈 디렉터리 이외의 디렉터리에서 작동하므로 경로가 달라진다.)  
  
  
사용자 데이터 스크립트의 경우 모듈 자체에 상대 경로가 필요하므로,  
``modules/services/webserver-cluster/main.tf`` 의 template_file 데이터 소스에서 path.module 을 사용해야 한다.  
```  
data "template_file" "user_data" {  
    // 웹 서버 클러스터의 사용자 데이터 스크립트를 외부 파일인 user-data.sh로 이동하고, 내장 함수 file을 사용하여 디스크에서 파일을 읽음  
    template = file("${path.module}/user-data.sh")  
    
    vars = {  
        server_port = var.server_port  
        db_address = data.terraform_remote_state.db.outputs.address  
        db_port = data.terraform_remote_state.db.outputs.port  
    }  
}  
```  
  
  
### 04-5.2 인라인 블록  
일부 테라폼 리소스의 구성은 인라인 블록 또는 별도의 리소스로 정의할 수 있다.  
모듈을 만들 때는 항상 별도의 리소스를 사용하는 것이 좋다.  
  
예를 들어, aws_security_group 리소스를 사용하면 webserver-cluster 모듈(modules/services/webserver-cluster/main.tf)에서 볼수 있듯  
인라인 블록을 통해 수신(ingress) 및 송신(egress) 규칙을 정의할 수 있다.  
```  
resource "aws_security_group" "alb" {  
    name = "${var.cluser_name}-alb"  
    
    ingress {  
        from_port = local.http_port  
        to_port = local.http_port  
        protocol = local.tcp_protocol  
        cidr_blocks = local.all_ips  
    }  
    
    egress {  
        from_port = local.any_port  
        to_port = local.any_port  
        protocol = local.any_protocol  
        cidr_blocks = local.all_ips  
    }  
}  
```  
  
별도의 aws_security_group_rule 리소스를 사용하여  
정확히 동일한 수신 및 송신 규칙을 정의하도록 이 모듈을 변경해야 한다.  
(모듈의 두 보안 그룹 모두에 이 작업을 수행해야 한다.)  
```  
resource "aws_security_group" "alb" {  
    name = "${var.cluser_name}-alb"  
}  

resource "aws_security_group_rule" "allow_http_inbound" {  
    type = "ingress"  
    security_group_id = aws_security_group_alb.id  
    
    from_port = local.http_port  
    to_port = local.http_port  
    protocol = local.tcp_protocol  
    cidr_blocks = local.all_ips  
}  

resource "aws_security_group_rule" "allow_all_outbound" {  
    type = "egress"  
    security_group_id = aws_security_group_alb.id  
    
    from_port = local.any_port  
    to_port = local.any_port  
    protocol = local.any_protocol  
    cidr_blocks = local.all_ips  
}  
```  
  
  
인라인 블록과 별도의 리소스를 혼합하여 사용하려고 하면 라우팅 규칙이 충돌하여 서로 덮어쓰는 오류가 발생한다.  
따라서 둘 중 하나만 사용해야 한다.  
이 제한사항으로 인해 모듈을 작성할 때 항상 인라인 블록 대신 별도의 리소스를 사용해야 한다. 그렇지 않으면 모듈의 유연성이 떨어진다.  
  
  
예를 들어 webserver-cluster 모듈 내의 모든 수신 및 송신 규칙이 별도의 aws_security_group_rule 리소스로 정의된 경우  
사용자가 모듈 외부에서 사용자 정의 규칙을 추가할 수 있도록 모듈을 유연하게 만들 수 있다.  
이를 위해 web_security_group의 ID를 modules/services/webserver-cluster/output.tf 에서 출력 변수로 내보낸다.  
```  
output "alb_security_group_id" {  
    value = aws_security_group.alb.id  
    description = "The ID of the Security Group attached to the load balancer"  
}  
```  
  
  
이제 스테이징 환경에서 테스트를 위해 포트를 추가로 노출해야 한다고 가정한다.  
aws_security_group_rule 리소스를 stage/services/webserver-cluster/main.tf 에 추가하기만 하면 된다.  
```  
resource "aws_security_group_rule" "allow_testing_inbound" {  
    type = "ingress"  
    security_group_id = module.webserver_cluster.alb_security_group_id  
    
    from_port = 12345
    to_port = 12345  
    protocol = "tcp"  
    cidr_bloicks = ["0.0.0.0/0"]  
}  
```  
  
  
인라인 블록을 단일 수신 또는 송신 규칙을 정의한 경우에도 코드가 작동하지 않는다.  
이러한 유형의 문제는 다음과 같은 여러 테라폼 리소스에 영향을 미친다.  
-aws_security_group 과 aws_security_group_rule  
-aws_route_table 과 aws_route  
-aws_network_acl 과 aws_net_work_acl_rule  
  
  
이제 스테이징 환경과 프로덕션 환경 모두에 웹 서버 클러스터를 배포할 준비가 되었다.  
``terraform apply`` 명령을 실행하여 별도의 분리된 2개의 인프라를 생성한다.  
  
  
이 책의 모든 예제는 VPC(가상 프라이빗 클라우드)에 배포하기에 스테이징 환경의 서버가 프로덕션 환경의 서버와 서로 통신할 수 있다.  
간단한 예제와 실험 외에는 각 환경을 별도의 VPC에서 실행해야 한다.  
격리 수준을 더 높이려면 아예 다른 AWS 계정으로 실행하는 방법도 있다.  
(격리 수준을 높이려면 별도의 VPC를 통해 네트워크를 격리하는 것이 바람직하다.)  
  
  
### 04-6 모듈 버전 관리  
스테이징 환경과 프로덕션 환경이 동일한 모듈 폴더를 가리키는 경우 해달 폴더를 변경하면 바로 다음 배포 시 두 환경 모두에 영향을 미친다.  
이러한 종류의 결합은 프로덕션에 영향을 비치지 않고 스테이징 변화를 테스트하기 어렵게 만들다.  
그림 4-5와 같이 0.0.2 버전을 스테이징 환경에서 사용하고  
0.0.1 버전은 프로덕션 환경에서 사용할 수 있도록 버전이 지정된 모듈(versioned modules)을 만드는 것이 더 적절한 접근 방식이다.  
버전이 지정된 모듈을 만드는 가장 쉬운 방법은 모듈의 코드를 별도의 깃 리포지터리에 넣고 source 매개 변수를 해당 리포지터리의 URL로 설정하는 것이다.  
(다시 말해 테라폼 코드를 적어도 2개 리포지터리에 분산하는 것이다.)  
-모듈(modules): 이 리포지터리는 재사용 가능한 모듈을 정의한다.  
(각 모듈을 인프라의 특정 부분을 정의하는 청사진으로 생각한다.)  
  
-라이브(live): 이 리포지터리는 스테이징, 프로덕션, 관리 등 각 환경에서 실행 중인 인프라를 정의한다.  
(모듈 리포지터리의 청사진에서 구축한 집이라고 생각한다.)  
  
  
그림 4-6과 같은 폴더 구조를 설정하려면 stage, prod, global 폴더를 live라는 폴더로 이동해야 한다.  
그런 다음 live폴더와 modules 폴더를 분리된 깃 리포지터리로 구성한다.  
modules 폴더에서 수행작업  
```  
cd modules  
git init  
git add .  
git commit -m "Initial commit of modules repo"  
git remote add origin "(URL OF REMOTE GIT REPOSITORY)"  
git push origin master  

git tag -a "v0.0.1" -m "First release of webserver-cluster module"  
git push --follow-tags  
```  

source 매개 변수에 깃 URL을 지정하여 스테이징 환경과 프로덕션 환경 모두에서 버전이 지정된 모듈을 사용할 수 있다.  
modules 리포지터리가 깃허브 리포지터리 ``github.com/foo/modules``에 있는 경우  
``live.stage/services/webserver-cluster/main.tf``에 다음과 같이 표시된다.  
(깃 URL에는 슬래시 2개가 필요하다.)  
```  
module "webserver_cluster" {  
    source = "github.com/foo/modules//webserver-cluster?ref=v0.0.1"  
    
    cluster_name = "webservers-stage"  
    db_remote_state_bucket = "(YOUR_BUCKET_NAME)"  
    db_remote_state_key = "stage/data-stores/mysql/terraform.tfstate"  
    
    instance_type = "t2.micro"  
    min_size = 2  
    max_size = 2  
}  
```  
버전이 지정된 모듈 URL을 사용하도록 테라폼 코드를 업데이트했으니 ``terraform init``을 다시 실행해 테라폼이 모듈 코드를 다운로드하도록 지시해야 한다.  
(테라폼이 로컬 파일 시스템이 아닌 깃에서 모듈 코드를 다운로드하는 것을 알 수 있다.  
모듈 코드를 다운로드한 후 평소대로 apply 명령을 실행할 수 있다.  
  
  
버전이 지정된 모듈을 사용하게 되었으니 변경 프로세스를 진행하는 과정을 본다.  
webserver-cluster 모듈을 이부 변경했고 이를 스테이징 단계에서 테스트한다면, 모듈 리포지터리에 변경 사항을 커밋한다.  
```  
cd modules  
git add .  
git commit -m "Made some changes to webserver-cluster"  
git push origin master  

git tag -a "v0.02" -m "Second release of webserver-cluster"  
git push --follow-tags  
```  
  
  
```    
참고: 개인 깃 리포지토리  
테라폼 모듈이 개인 깃 리포지터리에 있는 경우 해당 리포지터리의 모듈의 source에 사용하려면  
테라폼에 해당 깃 리포지터리를 인증할 수 있는 방법을 제공해야 한다.  
코드 자체에 리포지터리의 자격 증명을 하드 코딩할 필요가 없도록  
SSH 인증을 사용하는 것을 권한다.  
SSH 인증을 사용하면 각 개발자는 SSH 키를 생성하여 이를 깃 사용자와 연관시키고  
ssh-agent에 추가할 수 있으며  
SSH source URL을 사용하는 경우 테라폼은 인증을 위해 해당 키를 자동으로 사용한다.  
source URL은 다음과 같은 형식이어야 한다.  
``git@github.com:<OWNER>/<REPO>.git//<PATH>?ref=<VERSION>``  
```  
  
이제 스테이징 환경에서 사용되는 소스 URL(live/stage/services/webserver-cluster/main.tf)만 업데이트하여 새 버전을 사용할 수 있다.  
```  
module "webserver_cluster" {  
    source = "git@github.com:foo/modules.git//webserver-cluster?ref=v0.0.2"  
    
    cluster_name = "webservers-stage"  
    db_remote_state_bucket = "(YOUR_BUCKET_NAME)"  
    db_remote_state_key = "stage/data-stores/mysql/terraform.tfstate"  
    
    instance_type = "t2.micro"  
    min_size = 2  
    max_size = 2  
}  
```  
  
프로덕션(live/prod/services/webserver-cluster/main.tf)에서는 업데이트하지 않은 0.01 버전을 계속 실행할 수 있다.  
```  
module "webserver_cluster" {  
    source = "git@github.com:foo/modules.git//webserver-cluster?ref=v0.0.1"  
    
    cluster_name = "webservers-prod"  
    db_remote_state_bucket = "(YOUR_BUCKET_NAME)"  
    db_remote_state_key = "prod/data-stores/mysql/terraform.tfstate"  
    
    instance_type = "m4.large"  
    min_size = 2  
    max_size = 10  
}  
```  
  
철저하게 테스트하고 스테이징에서 검증한 후에는 프로덕션도 업데이트를 할 수 있다.  
버그를 수정하고 새 버전을 출시한 후 프로덕션 환경에 안정적일 때까지 전체 프로세스를 다시 반복한다.  
  
  
### 04-7 결론  
모듈에서 코드형 인프라를 정의하면 다음과 같은 이점이 있다.  
1. 다양한 소프트웨어 엔지니어링 모범 사례를 인프라에 적용할 수 있다.  
2. 코드 리뷰 및 자동화된 테스트를 통해 모듈의 각 변경 사항을 확인할 수 있다.  
3. 각 모듈에 버전을 지정하여 배포할 수 있다.  
4. 다른 환경에서 다른 버전의 모듈을 안전하게 사용해보고 문제가 발생하면 이전 버전으로 롤백할 수 있다.  
  
개발자들이 검증과 테스트를 거쳐 문서화된 인프라 전체를 재사용할 수 있기 때문에 인프라를 빠르고 안정적으로 구축할 수 있다.  
예를 들어 클러스터를 실행하는 방법,  
로드에 따라 클러스터를 확장하는 방법,  
클러스터에 트래픽을 분배하는 방법 등 단일 마이크로서비스를 배포하는 방법을 정의하는 표준 모듈을 만들어 각 팀에서 사용할 수 있다.  
이 모듈은 몇 줄의 코드만으로 자체 마이크로서비스를 관리할 수 있게 해준다.  
  
이러한 모듈을 여러 팀에서 사용할 수 있게 하려면 해당 모듈의 테라폼 코드가 유연하고 구성 가능해야 한다.  
예를 들어 한 팀은 모듈을 사용하여 로드 밸런서 없이 마이크로서비스의 단일 인스턴스를 배포하고,  
다른 팀은 로드 밸런서가 있는 마이크로서비스의 인스턴스 여러 개를 사용하여 인스턴스 간에 트래픽을 분산시킬 수 있다.  

5장에서 살표볼 내용  
-테라폼에서 조건문은 어떻게?  
-for 반복문을 수행하는 방법은?  
-테라폼을 사용하여 변경 사항을 마이크로서비스에 중단 없이 롤아웃하는 방법은?  
  
  
  
## 06 프로덕션 수준의 테라폼 코드  
프로덕션 수준의 인프라란 서버, 데이터 저장소, 로드 밸런서, 보안 기능, 모니터링 및 경고 도구, 파이프라인 구축 및 비즈니스 운영에 필요한 기타 모든 기술을 의미한다.  
즉, 트래픽 과부하로 인프라가 중단되거나 장애가 발생하여 데이터가 손실되거나 해커의 침입으로 데이터에 문제가 생겨 비즈니스가 중단되는 문제들이 발생하지 않는 환경을 의미한다.  
  
필자가 경함한 바에 따른 프로덕션 수준의 인프라를 처음부터 구축하는데 인프라유형별 소요되는 시간     
1. 관리형 서비스  
ex)아마존 RDS를 사용하여 MYSQL을 실행하는 등 제3자에 의해 완전 관리되는 서비스를 배포하려는 경우 해당 서비스를 프로덕션 환경에 준비하는 데 1~2주 소요  
  
2. 스스로 관리하는 분산 시스템(상태 비저장)  
ex)모든 데이터를 RDS에 저장하는 것 같이 데이터를 로컬에 저장하지 않는 Node.js 앱 클러스터, 즉 상태 비저장 분산 앱을 AWS 오토스케일링 그룹에서 실행하려는 경우 프로덕션 환경 준비에 약  2~4주 소요  
  
3. 스스로 관리하는 분산 시스템(상태 저장)  
ex)AWS 오토스케일링 그룹에서 실행되고 로컬 디스크에 데이터를 저장하는 아마존 엘라스틱서치 클러스터와 같은 자체 상태 저장 분산 앱을 실행하려는 경우 2~4개월 소요  
  
4. 전체 아키텍처  
ex)애플리케이션, 데이터, 로드 밸런서, 모니터링 등을 포함한 전체 아키텍쳐를 구축하려는 경우 6~36개월 소요  
  
이 장에서는 프로덕션 수준의 인프라를 구축하는 데 왜 오랜 시간이 걸리는지,  
프로덕션 수준이란 실제로 무엇을 뜻하는지,  
그리고 재사용 가능한 프로덕션 수준의 모듈을 만드는 데 가장 적합한 패턴이 무엇인지 살펴본다.  
  
  
### 06-1. 프로덕션 수준 인프라 구축에 오랜 시간이 걸리는 이유  
데브옵스 작업에 오래 시간이 걸리는 데는 3가지 이유가 있다.  
첫 번째 이유는 데브옵스 산업이 여전히 석기 시대에 있기 때문이다.  
-테라폼, 도커, 패커 및 쿠버네티스와 같은 도구는 모두 2010년 중반에서 후반에 출시되었고, 이러한 모든 도구와 기술은 새롭고 빠르게 변화하고 있다.  
이러한 기술들은 충분히 성숙하지 않았고 소수의 사람들만 경험한 것들이기 때문에 프로젝트에 예상보다 오랜 시간이 걸린다.  
  
두 번째 이유는 데브옵스가 특히 '야크 털 깎기'에 취약하기 때문이다.  
-야크 털 갂기는 원래 하고 싶었던 작업을 수행하기 전 해야 하는 하찮고, 겉으로 볼때는 관련이 없는 작업들을 말한다.  
예를 들어, 앱 구성에서 버그를 촉발시키는 작은 오타를 수정해 배포 후 수정 출시하면 갑자기 TLS 인증서 문제가 발생한다.  
스택 오버플로에서 시간을 보낸 후 TLS 문제를 해결하고 다시 배포를 시도하면 이번에는 배포 시스템의 문제로 인해 실패한다.  
결국 한글자 오타 수정을 배포하기 위해 전체 서버 집합의 운영 체제 버전을 업데이트해야 한다. 
- 생각해보기 jsp 한 페이지 수정할 때 내 것만 고칠 것인가 발견한 버그를 같이 고칠 것인가?  
  
세 번째 이유는 본질적 복잡성은 프로덕션 인프라를 준비하기 위해 수행해야 하는 작업의 체크 리스트가 너무 길기 때문이다.  
-대다수 개발자가 체크 리스트에 있는 대부분의 항목을 알지 못하기 때문에 프로젝트를 평가할 때 중요하고 시간이 많이 걸리는 세부 사항을 잊어버린다.  
  
  
### 06-2. 프로덕션 수준 인프라 체크 리스트  
"프로덕션 환경으로 전환하는 데 필요한 것이 뭐가 있죠?" 라고 5명에게 질문 한다면, 5가지 다른 답변을 들을 수 있다.  
예를 들어, 어떤 사람은 성능 지표 및 경고의 필요성을 언급할 것이다.  
또 다른 사람은 용량 계획 및 고가용성에 대해 얘기할 것이다.  
이처럼 대부분 회사는 프로덕션 단계로 전환하기 위한 요구 사항을 명확하게 정의하고 있지 않으며,  
이는 각 인프라가 약간 다르게 배포되거나 중요한 기능이 누락될 수 있음을 의미한다.  
  
표 6-2 프로덕션 수준의 인프라 체크 리스트  
새로운 인프라에서 작업할 때마다 이 체크 리스트를 살펴보아야 한다.  
체크 리스트의 모든 항목이 모든 인프라에 필요하진 않지만 어떤 항목을 구현했는지, 어떤 항목을 건너뛰기로 결정했는지, 그 이유는 무엇인지를 의식적으로 그리고 명시적으로 문서화해야 한다.  
  
  
### 06-3. 프로덕션 수준 인프라 모듈  
재사용 가능한 모듈을 구축하는 모범 사례를 살펴본다.  
- 소형 모듈  
- 합성 가능한 모듈  
- 테스트 가능한 모듈  
- 릴리스 가능한 모듈  
- 테라폼 모듈 외의 것들  
  
  
### 3.1 소형 모듈  
대형 모듈의 단점  
1. 속도가 느림  
모든 인프라가 하나의 테라폼 모듈에 정의되어 있으면 명령을 실행하는 데 시간이 오래 걸린다.  
모듈이 너무 커지면 ``terraform plan`` 명령을 실행하는 데만 5~6분 걸린다.  
  
2. 안전하지 않음  
모든 인프라가 하나의 큰 모듈로 관리되는 경우 어떤 것을 변경하려면 모든 엑세스 권한이 필요하다.  
따라서 거의 모든 사용자가 관리자 권한을 가지는 것을 의미하며 최소 권한 원칙에 위배된다.  
  
3. 위험성이 높음  
스테이징 환경에서 프런트엔드 앱을 약간 변경했을 뿐인데 오타나 잘못된 명령으로 인해 프로덕션 데이터베이스를 삭제할 수 있다.  
  
4. 이해하기 어려움  
한 곳에 코드가 많을 수록 한 사람이 모든 것을 이해하기가 더 어려워진다.  
  
5. 리뷰하기 어려움  
수십 줄의 코드로 구성된 모듈을 리뷰하는 것은 쉽지만, 수천 줄의 경우 거의 불가능하다.  
  
6. 테스트하기 어려움  
많은 양의 인프라 코드를 테스트하는 것은 거의 불가능하다.  
  
  
따라서 각각 한 가지 일을 하는 소형 모듈로 코드를 작성해야 한다.  
예를 들어 자바, 파이썬 또는 루비와 같은 범용 프로그래밍 언어로 작성한 다음과 같은 2만 줄 길이의 함수보다는,  
각각 하나의 작업을 수행하는 여러개의 작은 독립형 함수로 리팩터링하는 것이 더 좋은 방법이다.  
  
테라폼에서도 동일한 전략을 사용해야 하는데, 여러 개의 작은 독립형 모듈로 리팩터링하는 것이 더 좋은 방법이다.  
지금까지 구축한 webserver-cluster 모듈이 커지기 시작했으며, 다소 관련성이 없는 다음 3가지 작업을 처리하고 있다.  
1. 오토스케일링 그룹(ASG)  
-webserver-cluster 모듈은 무중단 롤링 배포를 수행할 수 있는 ASG를 배포한다.  
  
2. 애플리케이션 로드 밸런서(ALB)  
-webserver-cluster는 ALB를 배포한다.  
  
3. Hello, World 애플리케이션  
-webserver-cluster 모듈은 간단한 'Hello, World'앱도 배포한다.  
  
이에 따라 코드를 소형 모듈 3개로 리팩터링 해본다.  
1. modules/cluster/asg-rolling-deploy  
-무중단 롤링 배포를 수행할 수 있으며 ASG를 배포하기 위한 재사용 가능한 일반 독립형 모듈  
  
2. modules/networking/alb  
-ALB를 배포하기 위한 재사용 가능한 일반 독립형 모듈  
  
3. modules/services/hello-world-app  
-'Hello, World'앱을 배포하기 위한 모듈  
  

작업순서  
1. modules/services/webserver-cluster/main.tf 에서 modules/cluster/asg-rolling-deploy/main.tf 로 리소스를 이동, 즉 잘라서 붙여넣는다.  
-aws_launch_configuration  
-aws_autoscaling_group  
-aws_autoscaling_schedule(둘 다)  
-aws_security_group(인스턴스용이지만 ALB용은 아님)  
-aws_security_group_rule(인스턴스에 대한 규칙이지만 ALB에 대한 규칙은 아님)  
-aws_cloudwatch_metric_alarm(둘 다)  
  
2. modules/services/webserver-cluster/variables.tf 에서 modules/cluster/asg-rolling-deploy/variables.tf 로 변수를 이동한다.  
-cluster_name  
-ami  
-instance_type  
-min_size  
-max_size  
-enable_autoscaling  
-custom_tags  
-server_port  
  
3. modules/services/webserver-cluster/main.tf 에서 modules/networking/alb/main.tf 로 이동한다.  
-aws_lb  
-aws_lb_listener  
-aws_security_group(ALB용이지만 인스턴스용은 아님)  
-aws_security_group_rule(ALB에 대한 규칙이지만 인스턴스에 대한 규칙은 아님)  
  
4. modules/networking/alb/variables.tf를 작성하고 단일 변수를 정의한다.  
```  
variable "alb_name" {  
  description = "The name to use for this ALB"  
  type = string  
}  
```  
이 변수를 aws_lb 리소스와 aws_security_group 리소스에  name 인수로 사용한다.  
```  
resource "aws_lb" "example" {  
  name = var.alb_name  
  load_balancer_type = "application"  
  subnets = data.aws_subnet_ids.edfault.ids  
  security_groups = [aws_Security_group.alb.id]  
}  
```  
```  
resource "aws_security_group" "alb" {  
  name = var.alb_name  
}  
```  
(https://github.com/brikis98/terraform-up-and-running-code 6장 예제코드 참고)  
  
  
### 3.2 합성 가능한 모듈  
이제 한 가지 작업을 잘 수행하는 2개의 소형 모듈, 즉 asg-rolling-deploy 모듈과 alb 모듈이 있다.  
모듈들을 함께 작동시키는 한 가지 방법은 함수 합성(function composition)을 통해 한 함수의 출력을 다른 함수의 입력으로 전달하는 것이다.  
즉, 외부에서 상태를 읽는 대신 입력 매개 변수를 통해 전달하고,  
외부에 상태를 쓰는 대신 출력 매개 변수를 통해 계산 결과를 반환한다.  
모든 것을 입력 변수를 통해 전달하고 모든 것을 출력 변수를 통해 반환하며 간단한 모듈들을 결합해 더 복잡한 모듈을 만들 수 있다.  
  
1. modules/cluster/asg-rolling-deploy/variables.tf를 열고 새로운 입력 변수 4개를 추가한다.  
```  
# asg-rolling-deploy 모듈을 배포할 서브넷으로 지정  
# webserver-cluster 모듈은 기본 VPC 및 서브넷에 배포되도록 하드 코딩되어 있지만 subnet_ids 변수를 노출해 어떤 VPC나 서브넷에서도 사용할 수 있게 허용한다.  
variable "subnet_ids" {  
  description = "The subnet IDs to deploy to"  
  type = list(string)  
}  
  
# ASG를 로드 밸런서와 통합하는 방식을 구성  
# wevserver-cluster 모듈에는 ALB가 내장되어 있지만 asg-rolling-deploy 모듈은 일반 모듈이므로  
# 로드 밸런서 설정을 입력 변수로 노출하면 다양한 상황에서 ASG를 사용할 수 있다.(예를 들어 로드 밸런서가 없거나 하나의 ALB 또는 여러 NLB를 사용하는 상황에서 ASG를 사용할 수 있다.)  
variable "target_group_arns" {  
  description = "The ARNs of ELB target groups in which to register Instances"  
  type = list(string)  
  default = []  
}  
  
# ASG를 로드 밸런서와 통합하는 방식을 구성  
variable "health_check_type" {  
  description = "The type of health check to perform. Must be one of: EC2, ELB."  
  type = string  
  default = "EC2"  
}  
  
# 사용자 데이터 스크립트를 전달하기 위한 것  
# 사용자 데이터 스크립트를 입력 변수로 사용하면 asg-roll-deploy 모듈은 ASG 전체에 어떤 앱이든 배포할 수 있다.  
variable "user_data" {  
  description = "The User Data script to run in each Instance at boot"  
  type = string  
  default = null  
}  
```  
  
2. 위에서부터 3가지 입력 변수를 modules/cluster/asg-rolling-deploy/main.tf 의 aws_autoscaleng_group 리소스에 전달하여  
ALB 같은 이전에 하드 코딩된 리소스 및 aws_reas_ids 같은 데이터 소스를 참조하는 설정으로 대체한다.  
```  
resource "aws_autoscaling_group" "example" {  
  # 명시적으로 시작 구성의 이름에 의존하므로 교체될 때마다 이 ASG도 교체된다.  
  name = "${var.cluster_name}-${aws_launch_configuration.example.name}"  
  
  launch_configuration = aws_launch_configuration.example.name  
  vpc_zone_identifier = var.subnet_ids  
  
  # 로드 배런서와 통합 구성  
  target_group_arns = var.target_group_arns  
  health_check_type = var.health_check_type  
  
  min_size = var.min_size  
  max_size = var.max_size  
  
  # ASG 배포 완료 전 최소한 이 인스턴스가 상태 확인을 통과할 때까지 기다립니다.  
  min_elb_capacity = var.min_size  
  
  # (...)  
}  
```  
  
3. user_data 변수를 aws_launch_configuration 리소스로 전달한다.  
asg-rolling-deploy 모듈에 복사하지 않은 template_file 데이터 소스에 대한 참조를 대체한다.  
```  
resource "aws_launch_configuration" "example" {  
  image_id = var.ami  
  instance_type = var.instance_type  
  security_groups = [aws_security_group.instance.id]  
  user_data = var.user_data  
  
  # 오토스케일링 그룹과 함께 시작 구성을 사용할 때 필요하다.  
  # https://www.terraform.io/docs/providers/aws/r/launch_configuration.html  
  lifecycle {  
    create_before_destroy = true  
  }  
}  
```  
  
4. modules/cluster/asgrolling-deploy/outputs.tf 에 유용한 출력 변수 몇 개를 추가한다.  
이 데이터를 출력하면 모듈의 소비자가 이러한 출력을 사용하여 보안 그룹에 사용자 정의 규칙을 추가하는 등 새로운 동작을 추가할 수 있기 때문에 , asg-roll-deploy 모듈의 재사용성을 높인다.  
```  
output "asg_name" {  
  value = aws_autoscaling_group.example.name  
  description = "The name of the Auto Scaling Group"  
}  
  
output "instance_security_group_id" {  
  value = aws_security_group.instance.id  
  description = "The ID of the EC2 Instance Security Group"  
}  
  
5. 비슷한 이유로 modules/networking/alb/outputs.tf에 여러 출력 변수를 추가한다.  
```  
output "alb_dns_name" {  
  value = aws_lb.example.dns_name  
  description = "The domain name of the load balancer"  
}  
  
output "alb_http_listener_arn" {  
  value = aws_lb_listener.http.arn  
  description = "The ARN of the HTTP listener"  
}  
  
output "alb_security_group_id" {  
  value = aws_security_group_alb.id  
  description = "The ALB Security Group ID"  
}  
```  
  
6. asg-rolling-deploy 및 alb 모듈을 사용하여 webserver-cluster 모듈을 'Hello, World' 앱을 배포할 수 있는 hello-world-app 모듈로 변환한다.  
(modules/services/webserver-cluster 의 이름을 modules/services/hello-world-app 으로 변경한다.)  
modules/services/hello-world-app/variables.tf 에 다음 변수를 추가한다.  
```  
variable "environment" {  
  description = "The name of the environment we're deploying to"  
  type = string  
}  
```  
이전에 작성한 asg-rolling-deploy 모듈을 hello-world-app 모듈에 추가하여 ASG를 배포한다.  
```  
module "asg" {  
  source = "../../cluster/asg-rolling-deploy"  
  
  cluster_name = "hello-world-${var.environment}"  
  ami = var.ami  
  user_data = data.template_file.user_data.rendered  
  instance_type = var.instance_type  
  
  min_size = var.min_size  
  max_size = var.max_size  
  enable_autoscaling = var.enable_autoscaling  
  
  subnet_ids = data.aws_subnet_ids.default.ids  
  target_group_arns = [aws_lb_target_group.asg.arn]  
  health_check_type = "ELB"  
  
  custom_tags = var.custom_tags  
}  
```  
그리고 이전에 생성한 alb 모듈을 추가하여 배포한다.  
```  
module "alb" {  
  source = "../../networking/alb"  
  
  alb_name = "hello-world-${var.environment}"  
  subnet_ids = data.aws_subnet_ids.default.ids  
}  
```  
  
7. 이 앱에 대한 ALB 대상 그룹 및 리스너 규칙을 구성한다.  
(name에서 environment 를 사용하도록 modules/services/hello-world-app/main.tf 에서 aws_lb_target_group 리소스를 업데이트한다.)  
```  
resource "aws_lb_target_group" "asg" {  
  name = "hello-world-${var.environment}"  
  port = var.server_port  
  protocol = "HTTP"  
  vpc_id = data.aws_vpc.default.id  
  
  health_check {  
    path = "/"  
    protocol = "HTTP"  
    matcher = "200"  
    interval = 15  
    timeout = 3  
    healthy_threshold = 2  
    unhealthy_threshold = 2  
  }  
}  
```  
aws_lb_listener_rule 리소스의 listener_arn 매개 변수가 ALB 모듈의 alb_http_listener_arn 출력을 가리키도록 업데이트한다.  
```  
resource "aws_lb_listener_rule" "asg" {  
  listener_arn = module.alb.alb_http-listener_arn  
  priority = 100  
  
  condition {  
    field = "path-pattern"  
    values = ["*"]  
  }  
  
  action {  
    type = "forward"  
    target_group_arn = aws_lb_target_group.asg.arn  
  }  
}  
```  
asg-rolling-deploy 및 alb 모듈의 중요한 출력을 hello-world-app 모듈의 출력으로 전달한다.  
```  
output "alb_dns_name" {  
  value = module.alb.alb_dns_name  
  description = "The domain name of the load balancer"  
}  
  
output "asg_name" {  
  value = module.asg.asg_name  
  description = "The name of the Auto Scaling Group"  
}  
  
output "instance_security_group_id" {  
  value = module.asg.instance_security_group_id  
  description = "The ID of the EC2 Instance Security Group"  
}  
```  
  
  
  
끝  