# 자바  
  
  
### 프로그래밍 언어  
기계어(machine language)는 0, 1의 이진수로 구성된 언어로 CPU는 기계어만 이해 및 처리 가능하다.  
프로그래밍 언어로 작성된 텍스트 파일을 소스라고 하고, 소스 파일을 컴퓨터가 이해할 수 있는 기계어로 만드는 과정을 컴파일이라고 한다.  
자바의 경우 소스파일의 확장자는 java, 컴파일된 파일의 확장자는 class이며, JVM(Java Virtual Machine)이 클래스 파일을 실행시킨다.  
자바는 C언어가 기원인 C++로 부터 발전한 언어로, 환경으로 2가지가 있다.  

### JDK(Java Development Kit)  
자바 응용 개발 환경으로, 개발에 필요한 도구 포함한다.(컴파일러, JRE, 클래스 라이브러리, 샘플 등)  
설치과정은 http://java.sun.com에서 Java SE를 다운로드하여 환경변수를 설정 후, DOS 창에서 JDK를 확인한다.  
JAVA_HOME: JDK설치 위치  
CLAASSPATH: ;%JAVA_HOME%\lib\tools.jar  
(클래스패스는 하드디스크상에 클래스들이 어디에 위치하는지 경로를 지정한다.)  
path: 기존패스맨 앞%JAVA_HOME%\bin;  
  
java -version  
echo %JAVA_HOME%  
echo %path%  
javac First.java(컴파일)  
java First(실행)  
  
### JRE(Java Runtime Environment)  
자바 실행 환경으로 JVM이 포함되어 있으며, 자바 실행 환경만 필요한 경우 JRE만 다운로드 가능하다.  
  
  
### 실행과정  
1. Java 소스 작성  
2. 컴파일러(javac.exe) 컴파일  
3. class(소스코드를 Java 바이트 코드로 번역) 생성  
4. JVM이 바이트 코드를 읽고 실행  
  
  
### 자바 데이터 타입  
1. 래퍼런스 타입  
클래스 타입, 인터페이스 타입, 배열 타입, 열거 타입  
  
2. 프리미티브 타입  
수치타입  
byte 1 Byte  
char 2 Byte  
short 2 Byte  
int 4 Byte  
long 8 Byte  
float 4 Byte  
double 8 Byte  
불리언 타입  
1Byte로 초기값은 false  


### 배열  
인덱스를 가지고, 원하는 데이터를 한번에 접근하여 접근 속도가 빠름.  
크기 변경 불가.  
데이터 양이 많지만 삽입, 삭제가 없으며 데이터 접근이 빈번할 때 추천.  
데이터를 삽입, 삭제 후 그 위치의 다음위치부터 모든 데이터의 위치를 변경해야 하는 단점이 있다.  


### 연결리스트   
인덱스 대신 현재 위치의 이전/다음 위치를 기억. 크기가 가변적.  
한번에 접근 불가.  
연결되어 있는 링크를 따라가야 접근 가능하여 배열에 비해 속도가 떨어짐.  
데이터 삽입/삭제는 논리적 주소만 바꿔주기 때문에 용이하다.  
데이터 양이 적고, 삽입/삭제가 빈번할 때 추천.  

### 형변환(casting)  
예를들어, 실수를 정수로 바꾸는 것으로 반대는 자동변환이다. 즉, 작은타입 = (작은타입)큰타입  
  
  
### 연산자(operator)  
1. 비트연산자  
& 비트단위의 AND  
| 비트단위의 OR  
^ 비트단위의 XOR (00:0, 10:1, 01:1, 11:0)  
~ 비트단위의 보수  
십진수를 2진수로 변환시, 가중치(2의 거듭제곱)를 이용.  
0은 2의 보수를 이용하는데, 2의 보수는 1의 보수를 구한 후 1을 더한다.

2. 시프트 연산자  
">>" 오른쪽으로 이동(빈 자리는 양수는 0, 음수는 1), 2로 나눈 결과와 같음  
">>>" 빈자리는 항상(0)  
"<<" 빈자리는 항상(0) 왼쪽으로 이동, 2로 곱한 결과와 같음  
  
  
### 자바의 메모리 영역  
1. 메서드 영역  
static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.  
코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.  

2. 스택(Stack)  
지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리  

3. 힙(Heap)  
프로그래머가 관리하는 메모리 영역.  
new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.  


### 메모리 상수풀 영역  
힙영역에 생성되어 자바 프로세스 종료까지 계속 유지되는 메모리영역.  
기본적으로 JVM에서 관리하며 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고  
없으면 상수풀에 추가한 이후 그 주소값을 리턴한다.  
그로 인해 메모리 절약 효과가 있다.  

  
### 클래스  
물리적 공간을 갖는 구체적인 것을 객체라고 한다.  
클래스는 객체의 공통된 특징을 기술한 것으로, 객체의 특성과 행위를 정의한다.  
클래스를 구체화한 객체를 인스턴스라고 부르며, 사실상 객체와 인스턴스는 같은 뜻으로 사용한다.  

클래스의 형태는 필드(변수, 인스턴스 변수, 멤버 변수)와 메서드(함수, 인스턴스 메서드, 멤버 메서드)로 구성되어 있다.  

new는 메모리 할당으로, 객체명으로 할당된 메모리를 접근하는 용도로 사용한다.  
클래스 선언시, 하나의 파일 안에 public 클래스는 하나만 있을 수 있다.

  
### 멤버변수 vs 지역변수  
멤버변수  
1. 선언위치: 클래스 영역  
2. 각각의 객체마다 개별적인 속성을 가져야 할 때, 인스턴스 변수를 선언해서 사용.  
3. 모든 객체가 공통적으로 똑같은 속성을 가질 때, 클래스 변수를 선언해서 사용.  
  
지역변수  
1. 선언위치: 메서드나 생성자 내부  
2. 메서드가 종료되면 자동으로 소멸  
  
  
### 다중상속  
클래스를 이용하여 다중 상속을 할 경우 메서드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은 지원하지 않는다.  

  
### Abstract method(추상 메서드)    
선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다.  
즉, 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메서드이다.  
목적은 추상메서드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상메서드를 구현하도록 하기 위함이다.  
(만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.)  


### Abstract class(추상 클래스)   
추상메서드를 하나 이상 가진 클래스.  
클래스 구현부 내부에 추상 메서드가 하나 이상 포함되고, abstract로 정의된 경우를 말한다.  
추상 메서드를 포함하고 있다는 점을 제외하면, 일반 클래스와 모든점이 같다.  
(생성자와 필드, 일반 메서드도 포함할 수 있다.)  

주의  
자신의 생성자로 인스턴스 생성 불가능하다.  
그래서 먼저 상속을 통해 자식 클래스를 만들고, 만들 자식 클래스에서 추상 클래스의 모든 추상 메서드를 오버라이딩하고 나서야  
비로소 자식클래스의 인스턴스를 생성할 수 있게 된다.  

목적  
즉, 하위 클래스를 제어하기 위해 사용한다.  
```
abstract class Animal {  
    abstract void cry();  
}  

class Cat extends Animal {  
    void cry() {  
        System.out.println("냐옹냐옹!");  
    }  
}  

class Dog extends Animal {  
    void cry() {  
        System.out.println("멍멍!");  
    }  
}  

public class Polymorphism02 {  
    public static void main(String[] args) {  
        // Animal a = new Animal(); // 추상 클래스는 인스턴스를 생성할 수 없음.  
        Cat c = new Cat();  
        Dog d = new Dog();  
        c.cry(); // 냐옹냐옹!  
        d.cry(); // 멍멍!  
    }  
}  
```
  
### Interface(인터페이스)  
인터페이스는 하위 클래스에 특정한 메서드가 반드시 존재하도록 강제한다.  
또한 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록 한다.  
실질적으로는 협업자 상호간에 동일한 메서드를 만들도록 규약을 만드는데 이용할 수 있다.  

특징으로 다중 상속이 가능하다.  
멤버는 반드시 public이며, 오직 추상메서드와 상수만을 멤버로 갖는다.  
일종의 추상 클래스이다.  
추상 클래스와 다르게 하나의 클래스가 여러 개의 인터페이스를 구현 할 수 있지만,  
구체적인 로직이나 상태를 가지고 있을 수 없다.  
접근제어자 interface 인터페이스이름 {  
    public static final 타입 상수이름 = 값;  
    ...  
    public abstract 메서드이름(매개변수목록);  
    ...  
}  

  
### Interface vs Abstract  
공통점  
1. new 연산자로 인스턴스 생성 불가능.  
2. 프로토타입만 있는 메서드를 갖는다.  
3. 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.  
(다른 클래스를 작성하는데 도움 줄 목적으로 작성된다.)  

차이점  
1. 추상클래스를 부분적으로만 완성된 '미완성 설계도'라고 한다면,  
인터페이스는 구현된 것은 아무 것도 없고 밑그림만 그려져 있는 '기본 설계도'라 할 수 있다.  
2. 추상클래스는 일반 메서드를 사용할 수 있지만, 인터페이스는 메서드 선언만 가능하다.  
(인터페이스는 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.)  
  
  
### 제네릭  
클래스를 선언할 때 타입을 결정하지 않고 객체를 생성할 때 유동적인 타입으로 재사용하기 위한 것  
형변환을 할 필요없고, 타입 에러가 발생할 확률이 없어진다.    
  
  
### 참고자료  
1. [멤버변수 지역변수 전역변수 등 헷갈리지 않게 구분하기](https://easywebs.tistory.com/29)  
2. [인터페이스(interface)](https://opentutorials.org/module/2495/14142)  
3. [Java Fundamental](www.soldesk.com)  