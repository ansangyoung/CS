# 자바  
  
  
### 프로그래밍 언어  
기계어(machine language)는 0, 1의 이진수로 구성된 언어로 CPU는 기계어만 이해 및 처리 가능하다.  
프로그래밍 언어로 작성된 텍스트 파일을 소스라고 하고,  
소스 파일을 컴퓨터가 이해할 수 있는 기계어로 만드는 과정을 컴파일이라고 한다.  
자바의 경우 소스파일의 확장자는 java, 컴파일된 파일의 확장자는 class이며, JVM(Java Virtual Machine)이 클래스 파일을 실행시킨다.  
자바는 C언어가 기원인 C++로 부터 발전한 언어로, 환경으로 2가지가 있다.  
  
  
### JDK(Java Development Kit)  
자바 응용 개발 환경으로, 개발에 필요한 도구 포함한다.(컴파일러, JRE, 클래스 라이브러리, 샘플 등)  
설치과정은 http://java.sun.com에서 Java SE를 다운로드하여 환경변수를 설정 후, DOS창에서 JDK를 확인한다.  
JAVA_HOME: JDK 설치 위치  
CLAASSPATH: ;%JAVA_HOME%\lib\tools.jar  
(클래스패스는 하드디스크상에 클래스들이 어디에 위치하는지 경로를 지정한다.)  
path: 기존패스 맨 앞%JAVA_HOME%\bin;  
  
```  
java -version  
echo %JAVA_HOME%  
echo %path%  
javac First.java(컴파일)  
java First(실행)  
```  
  
    
### JRE(Java Runtime Environment)  
자바 실행 환경으로 JVM이 포함되어 있으며, 자바 실행 환경만 필요한 경우 JRE만 다운로드 가능하다.  
  
  
### 실행과정  
1. Java 소스코드 작성  
2. 컴파일러(javac.exe) 컴파일  
3. class(소스코드를 Java 바이트 코드로 번역) 생성  
4. JVM이 바이트 코드를 읽고 실행  
  
  
### 자바 데이터 타입  
-래퍼런스 타입  
클래스 타입, 인터페이스 타입, 배열 타입, 열거 타입  
  
-프리미티브 타입  
1. 수치타입  
byte 1 Byte  
char 2 Byte  
short 2 Byte  
int 4 Byte  
long 8 Byte  
float 4 Byte  
double 8 Byte  
  
2. 불리언 타입  
1 Byte로 초기값은 false  
  
  
### Boxing VS Unboxing  
자바에서는 모든 경우는 아니지만 대부분의 경우에는 자동으로 해준다.  
```  
int i = 1;  
Integer integer = i;  
int i2 = integer;  
```  
  
Boxing  
-Primitive 자료형 -> Wrapper 클래스  
-``Integer.valueOf(String)``: Integer 클래스를 리턴하기 때문에 산술 연산을 할 수 없다.  
  
Unboxing  
-Wrapper 클래스 -> Primitive 자료형  
-``Integer.parseInt(String)``: int 자료형을 리턴하기 때문에 산술 연산을 할 수 있다.  
  
  
### int VS Integer  
int  
-primitive 자료형으로 산술 연산이 가능하며 null로 초기화할 수 없다.  
  
Integer  
-Wrapper 클래스로 Unboxing을 하지 않으면 산술 연산이 불가능하지만, null 값을 처리할 수 있어서 SQL과 연동할 경우 처리가 용이하다.  
-DB에서 자료형이 정수형이지만 null 값이 필요한 경우 VO에서 Integer를 사용할 수 있다.  
  
  
### Mutable VS Immutable  
Mutable 클래스는 인스턴스가 생성된 후에 주소가 아닌 값의 내용을 변경할 수 있다.  
보통 setXxx()라는 이름의 메소드를 갖는 대부분의 클래스들이 Mutable 클래스이다.  
ex) String을 제외한 참조타입변수인 list, set 등  
변수의 값을 변경하면 할당된 메모리에 전달하여 객체 자체를 업데이트 한다.  
call by reference에 가깝다.  
  
Immutable 클래스는 일단 생성된 후에는 =으로 다시 받기 전에는 바뀌지 않는다.  
ex) int와 같은 기본 타입 및 String  
변수의 값을 변경하면 다른 객체를 생성하여 그 객체에 대한 참조로 업데이트 한다.  
즉, String은 새로 수정할 때마다 기존 메모리를 버리고 새로운 메모리에 값을 넣어서 연결한다.  
call by value에 가깝다.  
  
  
### Map VS Set  
공통적으로 순서가 보장되지 않는다.  
Map은 Key값의 중복은 허용하지 않지만 Value값의 중복은 허용한다.  
Set은 데이터의 중복을 허용하지 않는다.  
  
  
### 배열  
인덱스를 가지고, 원하는 데이터를 한번에 접근하여 접근 속도가 빠름.  
크기 변경 불가.  
주사용: 데이터 양이 많지만 삽입, 삭제가 없으며 데이터 접근이 빈번할 때 추천.  
단점: 데이터를 삽입, 삭제 후 그 위치의 다음 위치부터 모든 데이터의 위치를 변경해야 한다.  
  
  
### 연결리스트   
인덱스 대신 현재 위치의 이전/다음 위치를 기억. 크기가 가변적.  
한번에 접근 불가.  
연결되어 있는 링크를 따라가야 접근 가능하여 배열에 비해 속도가 떨어짐.  
데이터 삽입/삭제는 논리적 주소만 바꿔주기 때문에 용이하다.  
주사용: 데이터 양이 적고, 삽입/삭제가 빈번할 때 추천.  
  
  
### 형변환(casting)  
예를들어, 실수를 정수로 바꾸는 것으로 반대는 자동변환이다. 즉, 작은타입 = (작은타입)큰타입  
  
  
### 연산자(operator)  
1. 비트연산자  
& 비트단위의 AND  
| 비트단위의 OR  
^ 비트단위의 XOR (00:0, 10:1, 01:1, 11:0)  
~ 비트단위의 보수  
십진수를 2진수로 변환시, 가중치(2의 거듭제곱)를 이용.  
0은 2의 보수를 이용하는데, 2의 보수는 1의 보수를 구한 후 1을 더한다.  
  
2. 시프트 연산자  
">>" 오른쪽으로 이동(빈 자리는 양수는 0, 음수는 1), 2로 나눈 결과와 같음  
">>>" 빈자리는 항상(0)  
"<<" 빈자리는 항상(0) 왼쪽으로 이동, 2로 곱한 결과와 같음  
  
  
### 자바의 메모리 영역  
1. 메서드 영역  
static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.  
코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.  
  
2. 스택(Stack)  
지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리  
  
3. 힙(Heap)  
프로그래머가 관리하는 메모리 영역.  
new 연산자를 통한 동적 할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.  
  
  
### 메모리 상수풀 영역  
힙 영역에 생성되어 자바 프로세스 종료까지 계속 유지되는 메모리영역.  
기본적으로 JVM에서 관리하며 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고  
없으면 상수풀에 추가한 이후 그 주소값을 리턴한다.  
그로 인해 메모리 절약 효과가 있다.  
  
  
### 클래스  
물리적 공간을 갖는 구체적인 것을 '객체'라고 한다.  
클래스는 객체의 공통된 특징을 기술한 것으로, 객체의 특성과 행위를 정의한다.  
클래스를 구체화한 객체를 '인스턴스'라고 부르며, 사실상 객체와 인스턴스는 같은 뜻으로 사용한다.  
  
클래스의 형태는 필드(변수, 인스턴스 변수, 멤버 변수)와 메서드(함수, 인스턴스 메서드, 멤버 메서드)로 구성되어 있다.  
  
new는 메모리 할당으로, 객체명으로 할당된 메모리를 접근하는 용도로 사용한다.  
클래스 선언시, 하나의 파일 안에 public 클래스는 하나만 있을 수 있다.  
  
  
### 멤버변수 vs 지역변수  
-멤버변수  
1. 선언위치: 클래스 영역  
2. 각각의 객체마다 개별적인 속성을 가져야 할 때, 인스턴스 변수를 선언해서 사용.  
3. 모든 객체가 공통적으로 똑같은 속성을 가질 때, 클래스 변수를 선언해서 사용.  
  
-지역변수  
1. 선언위치: 메서드나 생성자 내부  
2. 메서드가 종료되면 자동으로 소멸  
  
  
### 다중상속  
클래스를 이용하여 다중 상속을 할 경우, 메서드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은 지원하지 않는다.  
  
  
### Abstract method(추상 메서드)  
선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상 메서드이다.  
즉, 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메서드이다.  
목적은 추상메서드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메서드를 구현하도록 하기 위함이다.  
(만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.)  
  
  
### Abstract class(추상 클래스)  
추상 메서드를 하나 이상 가진 클래스.  
클래스 구현부 내부에 추상 메서드가 하나 이상 포함되고, abstract로 정의된 경우를 말한다.  
추상 메서드를 포함하고 있다는 점을 제외하면, 일반 클래스와 모든점이 같다.  
(생성자와 필드, 일반 메서드도 포함할 수 있다.)  
  
-주의  
자신의 생성자로 인스턴스 생성 불가능하다.  
그래서 먼저 상속을 통해 자식 클래스를 만들고,  
만들 자식 클래스에서 추상 클래스의 모든 추상 메서드를 오버라이딩하고 나서야,  
비로소 자식클래스의 인스턴스를 생성할 수 있게 된다.  
  
-목적  
하위 클래스를 제어하기 위해 사용한다.  
```  
abstract class Animal {  
    abstract void cry();  
}  

class Cat extends Animal {  
    void cry() {  
        System.out.println("냐옹냐옹!");  
    }  
}  

class Dog extends Animal {  
    void cry() {  
        System.out.println("멍멍!");  
    }  
}  

public class Polymorphism02 {  
    public static void main(String[] args) {  
        // Animal a = new Animal(); // 추상 클래스는 인스턴스를 생성할 수 없음.  
        Cat c = new Cat();  
        Dog d = new Dog();  
        c.cry(); // 냐옹냐옹!  
        d.cry(); // 멍멍!  
    }  
}  
```  
  
  
### Interface(인터페이스)  
인터페이스는 하위 클래스에 특정한 메서드가 반드시 존재하도록 강제한다.  
또한 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록 한다.  
실질적으로는 협업자 상호간에 동일한 메서드를 만들도록 규약을 만드는데 이용할 수 있다.  
  
특징으로 다중 상속이 가능하다.  
멤버는 반드시 public이며, 오직 추상 메서드와 상수만을 멤버로 갖는다.  
(일종의 추상 클래스이다.)  
추상 클래스와 다르게 하나의 클래스가 여러 개의 인터페이스를 구현 할 수 있지만,  
구체적인 로직이나 상태를 가지고 있을 수 없다.  
```  
접근제어자 interface 인터페이스이름 {  
    public static final 타입 상수이름 = 값;  
    ...  
    public abstract 메서드이름(매개변수목록);  
    ...  
}  
```  
  
  
### Interface vs Abstract  
-공통점  
1. new 연산자로 인스턴스 생성 불가능.  
2. 프로토타입만 있는 메서드를 갖는다.  
3. 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.  
(다른 클래스를 작성하는데 도움 줄 목적으로 작성된다.)  
  
-차이점  
1. 추상클래스를 부분적으로만 완성된 '미완성 설계도'라고 한다면,  
인터페이스는 구현된 것은 아무 것도 없고 밑그림만 그려져 있는 '기본 설계도'라 할 수 있다.  
  
2. 추상클래스는 일반 메서드를 사용할 수 있지만, 인터페이스는 메서드 선언만 가능하다.  
(인터페이스는 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.)  
  
  
### 제네릭  
클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미한다.  
즉, 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 것이다.  
타입의 경계를 지정하고, 컴파일 때 해당 타입으로 캐스팅하여 매개변수화 된 유형을 삭제한다.  
이로써 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.  
  
따라서 클래스를 선언할 때 타입을 결정하지 않고 객체를 생성할 때 유동적인 타입으로 재사용하기 위한 것이며,  
형변환을 할 필요없고, 타입 에러가 발생할 확률이 줄어든다.  
관리하기 편하며, 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.  
  
  
### 참고자료  
1. [멤버변수 지역변수 전역변수 등 헷갈리지 않게 구분하기](https://easywebs.tistory.com/29)  
2. [인터페이스(interface)](https://opentutorials.org/module/2495/14142)  
3. [Java Fundamental](www.soldesk.com)  