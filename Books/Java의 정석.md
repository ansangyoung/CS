Java의 정석 3rd Edition  
남궁 성 지음  


Chapter 06 객체지향 프로그래밍1(Object-oriented Programming 1)  

1. 객체지향언어  

1.1 객체지향언어의 역사  
객체지향이론의 기본 개념은 '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.'라는 것이다.  
자바가 1995년에 발표되고 1990년대 말에 인터넷의 발전과 함께 크게 유행하면서 객체지향언어는 이제 프로그래밍언어의 주류로 자리 잡았다.  


1.2 객체지향언어  
객체지향언어의 주요틍징은 다음과 같다.  
1. 코드의 재사용성이 높다.  
-새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.  
2. 코드의 관리가 용이하다.  
-코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.  
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.  
-제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며,  
코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.  

너무 객체지향개념에 얽매여서 고민하기 보다는 일단 프로그램을 기능적으로 완성한 다음,  
어떻게 하면 보다 객체지향적으로 코드를 개선할 수 있을지를 고민하여 점차 개선해나가는 것이 좋다.



2. 클래스와 객체  

2.1 클래스와 객체의 정의와 용도  
클래스의 정의: 클래스란 객체를 정의해 놓은 것이다.(객체의 설계도)  
클래스의 용도: 클래스는 객체를 생성하는데 사용된다.  

객체
1. 사전적인 정의: 실제로 존재하는 것  
2. 객체지향이론에서의 정의: 사물과 같은 유형적인 것 뿐만 아니라, 개념이나 논리와 같은 무형적인 것들도 객체로 간주한다.  
3. 프로그래밍에서의 정의: 클래스에 정의된 내용대로 메모리에 생성된 것.  

즉, 클래스와 객체의 관계는 제품 설계도와 제품의 관계라고 할 수 있다. 예를들어 TV설계도는 TV라는 제품을 정의한 것이며, TV를 만드는데 사용된다.  

JDK(Java Develpment Kit)에서는 프로그래밍을 위해 많은 수의 유용한 클래스(Java API)를 기본적으로 제공하고 있으며,  
우리는 이 클래스들을 이용해서 원하는 기능의 프로그램을 보다 쉽게 작성할 수 있다.  


2.2 객체와 인스턴스  
클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며,  
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.  
결국 인스턴스는 객체와 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있으며,  
인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 갖고 있다.  

문맥에 따라 구별하여 사용하는 것이 좋다.  
1. 책상은 인스턴스다. VS 책상은 객체다.  
2. 책상은 책상 클래스의 객체이다. VS 책상은 책상 클래스의 인스턴스이다.  


2.3 객체의 구성요소 - 속성과 기능  
객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있다.  
속성과 기능은 같은 뜻의 여러 가지 용어가 있는데, 이 책은 속성은 멤버변수로, 기능은 메서드로 주로 사용하여 표현한다.  
속성(property): 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)  
기능(function): 메서드(method), 함수(function), 행위(behavior)  

TV를 예로 들면, TV의 속성으로는 전원상태, 크기, 길이, 높이, 색상, 볼륨, 채널과 같은 것들이 있으며,  
기능으로는 켜기, 끄기, 볼륨 높이기, 채널 변경하기 등이 있다.  
객체지향 프로그래밍에서는 속성과 기능을 각각 변수와 메서드로 표현한다.  
채널 -> ``int channel;``  
채널 높이기 -> ``channelUp() {...}``  
전원상태 -> ``boolean power;``  
전원 변경 -> ``void power() { power = !power; }``
- if문을 사용한다면?  
```  
if(power) {  
    power = false;  
} else {  
    power = true;  
}  
```  


2.4 인스턴스의 생성과 사용  
클래스로부터 인스턴스를 생성하는 방법은 여러 가지가 있다.  
```  
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언  
Tv t; // Tv클래스 타입의 참조변수 t를 선언. 메모리에 참조변수 t를 위한 공간이 마련된다. 아직 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 할 수 없다.  

변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장  
t = new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장. 
              // 1. Tv클래스의 인스턴스가 메모리의 빈 공간에 생성된다.   
              // 2. 멤버변수는 각 자료형에 해당하는 기본값으로 초기화된다. String -> null, boolean -> fale, int -> 0  
              // 3. 대입연산자에 의해서 생성된 객체의 주소값이 참조변수 t에 저장된다.(참조변수 t가 Tv인스턴스를 '가리키고 있다' 또는 '참조하고 있다'라고 한다.)  
```  

인스턴스와 참조변수의 관계는 마치 우리가 일상생활에서 사용하는 TV와 TV리모콘의 관계와 같다.  
TV리모콘(참조변수)을 사용하여 TV(인스턴스)를 다루기 때문이다.  
즉, TV인스턴스를 사용하려면, Tv클래스 타입의 참조변수가 필요한 것이다.  
(인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.)  


2.5 객체 배열  
객체 역시 배열로 다루는 것이 가능하며, 이를 '객체 배열'이라고 한다.  
객체 배열 안에 객체가 저장되는 것이 아니라, 객체의 주소가 저장된다.  
(참조변수들을 하나로 묶은 참조변수 배열인 것이다.)  
```  
Tv tv1, tv2, tv3;  
-> Tv[] tvArr = new Tv[3];  // 각 요소는 참조변수의 기본값인 null로 자동 초기화 된다.  
-> Tv[] tvArr = { new Tv(), new Tv(), new Tv() };  // 초기화블럭 사용시  
```  


2.6 클래스의 또 다른 정의  
-생략  


3. 변수와 메서드  

3.1 선언위치에 따른 변수의 종류  
변수는 클래스변수, 인스턴스변수, 지역변수 모두 세 종류가 있다.  
변수의 종류를 결정짓는 중요한 요소는 '변수의 선언된 위치'이다.  
멤버변수를 제외한 나머지 변수들은 모두 지역변수이며, 멤버변수 중 static이 붙은 것은 클래스변수, 붙지 않은 것이 인스턴스변수이다.  
```  
class Variables {  
    int iv; // 인스턴스 변수  
    static int cv; // 클래스변수  
    
    void method() { // 메서드 영역  
        int lv = 0; // 지역변수  
    }  
}  
```  
생성시기  
1. 클래스변수: 클래스가 메모리에 올라갈 때  
2. 인스턴스변수: 인스턴스가 생성되었을 때  
3. 지역변수: 변수 선언문이 수행되었을 때  

클래스변수 vs 인스턴스변수  
인스턴스는 독릭적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.  
인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스변수로 선언한다.  
이와 달리, 클래스변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다.  
한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스변수로 선언해야 한다.  
또한, 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있으며, 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때 까지 유지된다.  


3.2 클래스변수와 인스턴스변수  
-사용예시로 생략  


3.3 메서드  
특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것으로, 기본적으로 수학의 함수와 유사하다.  
메서드가 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐,  
이 메서드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 전혀 몰라도 된다.  

메서드를 사용하는 이유  
1. 높은 재사용성  
2. 중복된 코드의 제거  
3. 프로그램의 구조화  
-main메서드 안에 모든 문장을 넣는 식으로 프로그램을 작성하는 것보다는,  
문장들을 작업단위로 나눠서 여러 개의 메서드에 담아 프로그램의 구조를 단순화시키는 것이 좋다.  


3.4 메서드의 선언과 구현  
메서드의 이름은 이름만으로도 메서드의 기능을 쉽게 알 수 있도록 함축적이면서도 의미있는 이름을 짓도록 노력해야 한다.  


3.5 메서드의 호출  
메서드를 호출할 때 괄호()안에 지정해준 값들을 '인자(argument)' 또는 '인수'라고 한다.  
인자는 메서드가 호출되면서 매개변수에 대응되므로, 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.  

같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만,  
static메서드는 클래스의 인스턴스 없이 호출 가능하며, 인스턴스에서는 호출 할 수 없다.  
(유틸리티 함수를 만드는데 유용하게 사용된다.)  
```  
class Test {  
    Test () {}  
    static void m1 () {}  
    void m2 () {}  
}  
Test.m1() // O  
Test.m2() // X  

Test test = new Test();  
test.m1() // X  
test.m2() // O  
출처: https://mygumi.tistory.com/253 [마이구미의 HelloWorld]  
```  


3.6 return문  
반환타입이 void인 경우, return문 없이도 아무런 문제가 없었던 이유는 컴파일러가 메서드의 마지막에 'return;'을 자동적으로 추가해주었기 때문이다.  
```  
int add(int x, int y) {  
    int result = x + y;  
    return result;  
}  

int add(int x, int y) {  
    return x + y;  
}  
```  


3.7 JVM의 메모리구조  
응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.  
3가지 주요 영역(method area, call stack, heap)이 있다.  
1. 메서드 영역(method area)  
-프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(``*.class``)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다.  
이 때, 그 클래스의 클래스변수(``class variavle, ex)static int cv;``)도 이 영역에 함께 생성된다.  

2. 힙(heap)  
-인스턴스가 생성되는 공간이다. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.  
(즉, 인스턴스변수(instance variable)들이 생성되는 공간이다.)  

3. 호출스택(call stack)  
호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다.  
메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며,  
이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다.  
메서드가 작업을 마치면 할당되었던 메모리공간은 반한되어 비워진다.  

호출스택의 특징  
1. 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.  
2. 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.  
3. 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.  
4. 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.  


3.8 기본형 매개변수와 참조형 매개변수  
자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다.  
매개변수의 타입이 기본형일 때는 기본형 값이 복사되지만, 참조형이면 인스턴스의 주소가 복사된다.  
즉, 기본형 매개변수는 변수의 값을 읽기만 할 수 있고, 참조형 매개변수는 변수의 값을 읽고 변경할 수 있다.  


3.9 참조형 반환타입  
반환타입이 '참조형'이라는 것은 메서드가 '객체의 주소'를 반환한다는 것을 의미한다.  


3.10 재귀호출(recursive call)  
반복문 대신 재귀호출을 사용하는 이유는 재귀호출이 주는 논리적 간결함 때문이다.  
아무리 효율적이라도 알아보기 힘들게 작성하는 것보다  
다소 비효율적이라도 알아보기 쉽게 작성하는 것이 논리적 오류가 발생할 확률도 줄어들고, 나중에 수정하기도 좋다.  


3.11 클래스 메서드(static메서드)와 인스턴스 메서드  
(멤버변수는 인스턴스변수와 static 변수를 모두 통칭하는 말이다.)  
1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.  
2. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.  
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.  
-인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다.  
 인스턴스 변수가 존재한다는 것은 static변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.  
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.  
-메서드 호출시간이 짧아지므로 성능이 향상된다.  


3.12 클래스 멤버와 인스턴스 멤버간의 참조와 호출  
같은 클래스에 속한 멤버들 간에도 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다.  
단, 클래스멤버가 인스턴스 멤버들 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.  
(인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.)  
```  
class TestClass {  
    void instanceMethod() {} // 인스턴스메서드  
    static void staticMethod() {} // static메서드  
    
    void instanceMethod2() {  
        instanceMethod();  
        staticMethod();  
    }  
    
    void staticMethod2() {  
        instanceMethod();	// 에러  
        staticMethod();  
    }  
}  
```  

실제로는 같은 클래스 내에서 클래스멤버가 인스턴스멤버를 참조 또는 호출해야하는 경우는 드물다.  
만일 그런 경우가 발생한다면, 인스턴스메서드로 작성해야할 메서드를 클래스메서드로 한 것은 아닌지 한 번 더 생각해봐야 한다.  


4. 오버로딩(Overloading)  
4.1 오버로딩이란?
4.2 오버로딩의 조건  
4.3 오버로딩의 예  
4.4 오버로딩의 장점  
4.5 가변인자(varargs)와 오버로딩  

5. 생성자(constructor)  
5.1 생성자란?
5.2 기본 생성자(default constructor)  
5.3 매개변수가 있는 생성자  
5.4 생성자에서 다른 생성자 호출하기 - this(), this  
5.5 생성자를 이용한 인스턴스의 복사  

6. 변수의 초기화  
6.1 변수의 초기화  
6.2 명시적 초기화(explicit initialization)  
6.3 초기화 블럭(initialization block)  
6.4 멤버변수의 초기화 시기와 순서  
