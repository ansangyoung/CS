# 오브젝트  
### 조영호 지음  


### 객체, 설계    
이해가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다.  
객체 사이의 의존성은 변경에 대한 영향을 암시한다. 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.  
객체 사이의 의존성이 과한 경우를 가리켜 결합도가 높다고 한다. 두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다.  
개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 부른다. 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다. 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다.  
객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.  
밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다. 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.  
프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 부른다. 절차적 프로그래밍에서는 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다. 또한 변경하기 어려운 코드를 양상하는 경향이 있다.  
프로세스와 데이터를 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍이라고 부른다. 데이터와 프로세스를 하나의 단위로 통합해 놓는 방식으로 표현하기도 한다.  
동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다. 그래서 훌륭한 설계는 적절한 트레이드오프의 결과물이라는 사실을 명심해야 한다. 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있어야 한다.  


### 객체 분해  
불필요한 정보를 제거하고 현재의 무넺 해결에 필요한 핵심만 남기는 작업을 추상화라고 부른다. 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 분해라고 부른다.  
엄셈블리어는 숫자로 뒤범벅이 된 기계어에 인간인 이해할 수 있는 상징을 부여하려는 노력의 결과다. 고수준 언어는 기계적인 사고를 강요하는 낮은 수준의 명령어들을 탈피해서 인간의 눈높이에 맞는 기계 독립적이고 의미 있는 추상화를 제공하려는 시도의 결과였다. 프로그래밍 언어를 통해 표현되는 추상화의 발전은 다양한 프로그래밍 패러다임의 탄생으로 이어졌다.  


### 유연한 설계  
개방-폐쇄 원칙: 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.  
확장에 대해 열려 있다: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.  
수정에 대해 닫혀 있다: 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.  
추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다.  
불필요한 싱글톤 패턴은 객체 생성에 관해 너무 이른 시기에 고민하고 결정할 때 도입되는 경향이 있다. 객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다.  


### 객체지향 프로그래밍과 객체기반 프로그래밍  
객체기반 프로그래밍이란 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식을 가리킨다. 객체지향 프로그래밍은 마찬가지로 객체들을 조합해서 애플리케이션을 개발하지만 상속과 다형성을 지원한다는 점에서 차별화된다. 또한, 클래스를 사용하는 프로그래밍 방식을 의미한다.  


### 상속, 타입  
상속의 첫번째 용도는 타입 계층을 구현하는 것이다. 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다. 타입 계층의 관점에서 부모 클래스는 자식 클래스의 일반화이고 자식 클래스는 부모 클래스의 특수화다. 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다. 두번째 용도는 코드 재사용이다. 상속을 사용하면 점진적으로 애플리케이션의 기능을 확장할 수 있다.  
프로그래밍 언어 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다. 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다. 즉, 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다.  


### 디자인 패턴  
반복적으로 발생하는 문제와 해법의 쌍을 담고 있기 때문에 문제에 적합한 디자인 패턴을 고른다면 고품질의 설계를 짧은 시간에 얻을 수 있다. 설계를 트레이드오프할 수 있는 능력을 기를 수 있는 가장 좋은 방법인 동시에 훌륭한 객체지향 설계의 특징을 배울 수 있는 훌륭한 참고 자료다.  


### 리팩터링  
코드의 행동은 변경하지 않은 채 코드의 구조를 개선하는 활동을 의미한다. 설계는 코드의 배치이므로 코드의 구조를 개선한다는 것을 곧 설계를 개선한다는 것을 의미한다. 리팩터링에 익숙해지고 나면 일단 동작하는 코드를 완성한 후에 리팩터링을 통해 코드를 개선해가며 원하는 설계에 이를 수 있는 융통성을 얻게 된다.  


### 테스트 주도 개발  
테스트-구현-설계의 순서로 테스트를 통과하는 가장 간단한 코드를 구현한 후 설계를 리팩터링해서  완성한다. 메시지를 먼저 선택하고 메시지가 객체를 선택하게 한다는 책임-주도 설계 방법과도 잘 어울린다.  
