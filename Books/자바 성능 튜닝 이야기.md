# 자바 성능 튜닝 이야기  
  
### 디자인 패턴  
시스템을 만들기 위해서 전체 중 일부 의미 있는 클래스들을 묶은 각각의 집합으로, 반복되는 의미 있는 집합을 정의하고 이름을 지정해서 동일한 의미의 패턴이 되도록 만들어 놓은 것이다.  
Value Object라고도 불리는 Transfer Object는 데이터를 전송하기 위한 객체에 대한 패턴으로, 하나의 객체에 여러 타입의 값을 전달하는 일을 수행한다.  
즉, 하나의 객체에 결과 값을 담아 올 수 있어서 여러번 요청하는 것을 줄여준다.  
필드를 public으로 지정해서 메서드들을 만들지 않는 경우 성능상 더 빠르지만, 정보를 은닉하기 위한 getter(), setter() 메서드를 작성하는 것이 일반적이다.  
잘 만들어 놓으면 각 소스에서 일일이 null 체크를 할 필요가 없으며, JUnit 기반에 테스트를 위해 toString() 메서드를 반드시 구현하는 것이 좋다.  
Serializable 인터페이스를 구현하는 경우, 객체를 직렬화하여 서버 사이의 데이터 전송이 가능해진다.  
(원격지 서버에 데이터를 전송하거나, 파일로 객체를 저장할 경우에는 이 인터페이스를 구현해야 한다.)  
  
  
### CPU 시간  vs 대기 시간  
하나의 메서드, 한 라인을 수행하는데 소요되는 시간은 CPU 시간과 대기 시간으로 나뉜다. CPU를 점유한 시간과 점유하지 않고 대기하는 시간으로, 두 시간을 더하면 실제 소요시간(Clock time)이 된다.  CPU 시간은 툴에 따라서 스레드 시간으로 표시되기도 한다.  
  
  
### StringBuffer vs StringBuilder  
StringBuffer나 StringBuilder는 String과는 다르게 새로운 객체를 생성하지 않고, 기존에 있는 객체의 크기를 증가시키면서 값을 더한다.  
StringBuffer 클래스는 스레드에 안전하게 설계되어 있으므로, 여러 개의 스레드에서 하나의 StringBuffer 객체를 처리해도 전혀 문제가 되지 않는다. 따라서 개발중인 시스템의 부분이 스레드에 안전한지 모를경우, 클래스에 static으로 선언한 문자열을 변경하거나, singleton으로 선언된 클래스(JVM에 객체가 하나만 생성되는 클래스)에 선언된 문자열일 경우에는 이 클래스를 사용해야만 한다.  
StringBuilder는 단일 스레드에서의 안정성만을 보장한다. 스레드에 안전한지의 여부와 전혀 관계 없는 프로그램을 개발할 때 사용하면 좋다. 만약 메서드 내에 변수를 선언했다면, 해당 변수는 그 메서드 내에서만 살아있으므로, StringBuidler를 쓰면 된다.  
  
StringBuilder를 CharSequence로 받고 StringBuffer로 처리해도 정상적으로 처리된다. 굳이 값을 만든 후 toString을 수행하는것보다 메모리 효율에 더 좋다. 
  
  
### System Class  
모든 System 클래스의 메서드는 static으로 되어 있고, 그 안에서 생성된 in, out, err과 같은 객체들도 static으로 선언되어 있으며, 생성자도 없다.  
즉, System 객체는 우리가 생성할 수 없으며, System.XXX와 같은 방식으로 써야 한다.  
유용한 메서드인 ``static void arraycopy(Object src, int strPos, Object dest, int destPos, int length)`` 은  특정 배열을 복사할 때 사용한다. 차례대로 복사 원본 배열, 원본의 시작 위치, 복사한 값이 들어가는 배열, 복사본의 시작 위치, 복사하는 개수이다.  
  
  
### Garbage Collection  
자바에서 사용하는 한정된 공간의 메모리가 꽉 찼을 때 더 이상 필요 없는 객체들을 제거 하는 작업으로, 개발할 때는 GC가 '언제 되어야 할지'에 대해서 신경쓰면 안된다.  
``String a = new String(); a += aValue;``와 같은 작업은 새로운 String 클래스의 객체가 만들어지고(새로운 주소), 이전에 있던 a 객체는 필요 없는 쓰레기 값이 되어 GC 대상이 되어버린다. GC를 할수록 시스템의 CPU를 사용하게 되고, 시간도 많이 소요된다.  
  
  
### IO  
어떤 디바이스를 통해 이뤄지는 작업을 모두 IO라고 한다. 간단하게 콘솔에 출력하는 ``System.out.println("");``것도 스트림을 통해서 출력하는 것으로, out은 PrintStream을 System 클래스에 static으로 정의해 놓은 변수이다. 바이트 단위로 읽거나, 문자열 단위로 읽을 때 중요한 것은 한 번 연 스트림은 반드시 닫아 주어야 한다. 스트림을 닫지 않으면 나중에 리소스가 부족해질 수 있다. 파일을 처리할 때는 되도록이면 IOException을 따로 구분하여 처리하는 것이 좋다.  
  
자바를 사용하여 하드 디스크에 있는 데이터를 읽을때의 프로세스는  
1. 파일을 읽으라는 메서드를 자바에 전달한다.  
2. 파일명을 전달받은 메서드가 운영체제의 커널에게 파일을 읽어 달라고 요청한다.  
3. 커널이 하드 디스크로부터 파일을 읽어서 자신의 커널에 있는 버퍼에 복사하는 작업을 수행한다.  
4. 자바에서는 마음대로 커널의 버퍼를 사용하지 못하므로, JVM으로 그 데이터를 전달한다.  
5. JVM에서 메서드에 있는 스트림 관리 클래스를 사용하여 데이터를 처리한다.  
  
자바에서는 3번 복사 작업을 할 때나 4번 전달 작업을 수행할 때 대기하는 시간이 발생할 수밖에 없는데, 이를 보완하기 위해서 NIO(New IO)가 탄생했다. 3번 작업을 자바에서 직접 통제하여 시간을 더 단축할 수 있게 한 것이다.  
  
### static  
static은 원리를 알고 잘 사용하면 시스템의 성능을 향상시킬 수 있다.  
1. static으로 선언한 변수는 객체의 변수가 되는 것이 아니라 클래스변수가 된다.  
2. 클래스변수를 포함한 클래스의 인스턴스를 여러 개 생성하더라도, 모든 객체가 클래스 변수에 대해서는 동일한 주소의 값을 참조한다.  
-> 다른 JVM 에서는 static이라고 선언해도 다른 주소나 다른 값을 참조하지만, 하나의 JVM이나 WAS 인스턴스에서는 같은 주소에 존재하는 값을 참조한다.  
  
3. GC의 대상이 되지 않는다. 이는 곧 OutOfMemoryError 를 발생시킬 수 있으며, 이 경우 해당 인스턴스는 더이상 서비스할 수 없어서 시스템을 재시작해야 한다.  
-> 더 이상 사용 가능한 메모리가 없어지는 현상을 메모리릭이라고 하며, 원인은 메모리의 현재 상태를 파일로 남기는 HeapDump라는 파일을 통해서 확인 가능하다. JDK/bin 디렉토리에 있는 jmap이라는 파일을 사용하여 덤프를 남길 수 있으며, 남긴 덤프는 eclipse 프로젝트에서 제공하는 MAT와 같은 툴을 통해서 분석하면 된다.  
  
4. static을 잘못 사용하는 예로  다음을 기억해 두자.  
``private static boolean successFlg; // 응시자의 합격 여부 ``  
수십 명이 동시에 자신의 정보를 호출한다면, 다른 사용자의 요청에 의해 다른 결과를 받게 된다.  
  
  
### JSP  
JSP의 경우 가장 처음에 호출되는 경우에만 시간이 소요되고, 그 이후의 시간에는 컴파일된 서블릿 클래스가 수행된다.  
JSP의 라이프 사이클은   
1. JSP URL 호출  
2. JSP 페이지 번역  
3. JSP 페이지 컴파일  
4. 클래스 로드  
5. 인스턴스 생성  
6. jspInit 메서드 호출  
7. _jspService 메서드 호출  
8. jspDestory 메서드 호출  
  
서버의 종류에 따라서 서버가 기동될 때 컴파일을 미리 수행하는 Pre-compile 옵션이 있다. 
이 옵션을 선택하면 서버에 최신 버전을 반영한 이후에 처음 호출되었을 때 응답 시간이 느린 현상을 방지할 수 있지만, 개발 시에 이 옵션을 켜 놓으면 서버를 기동할 때마다 컴파일을 수행하기 때문에 시간이 오래걸린다.  
  
JSP include에는 ``<%@ include file="관련 URL"%>``와 같이 JSP 페이지 번역 및 컴파일 단계에서 필요한 JSP를 읽어서, 메인 JSP의 자바 소스 및 클래스에 포함을 시키는 정적인 방식과  
``<jsp:include page="relativeURL"/>``와 같이 페이지가 호출될 때마다 지정된 페이지를 불러들여서 수행하는 동적인 방식이 있다.  
  
WAS의 JVM이 시작한 후의 서블릿의 라이프 사이클은  
1. Servlet 객체가 자동으로 생성되고 초기화 되거나  사용자가 해당 Servlet을 처음으로 호출했을 때 생성되고 초기화  
2. 그 다음에는 계속 '사용 가능' 상태로 대기  
3. 중간에 예외가 발생하면 '사용 불가능' 상태로 빠졌다가 다시 '사용 가능' 상태로 변환   
4. 해당 서블릿이 더 이상 필요 없을 때, '파기' 상태로 넘아간 후 JVM에서 '제거'  
  
서블릿은 JVM에 여러 객체로 생성되지 않는다.  
WAS가 시작하고 '사용 가능' 상태가 된 이상 대부분의 서블릿은 JVM에 살아 있고, 여러 스레드에서 해당 서블릿의 service() 메서드를 호출하여 공유한다.  
service() 메서드를 구현할 때는 멤버 변수나 클래스 변수를 선언하여 지속적으로 변경하는 작업은 피해야 한다.  
  
WAS를 웹서버로 사용하면 안되며, 웹 서버는 반드시 WAS 앞에 두어야 한다.  
(웹 서버 하나에 WAS 두개이상 연동되는 경우 등을 고려하면 웹서버를 앞 단에 두는 것이 좋다.)  
  
  
### 사용 자제해야할 메소드  
1. ``static void gc()``  
자바에서 사용하는 메모리를 명시적으로 해제하도록 GC를 수행하는 메서드다.  
2. ``System.exit(int satatus)``  
현재 수행중인 JVM을 종료하는 메서드로, 매개변수인 int 값은 정상종료인지 아닌지를 나타내는 상태코드이다. 0은 정상종료를, 그렇지 않은 숫자는 비정상 종료를 의미한다.  
3. ``static void runFinalization()``  
Object 객체에 있는 finaliza()라는 메서드는 자동으로 호출되는데, 가비지 콜렉터가 알아서 해당 객체를 더 이상 참조할 필요가 없을 때 호출한다. 이 메서드를 호출하면 참조 해제 작업을 기자리는 모든 객체의 finalize() 메서드를 수동으로 수행해야 한다.  
  
  
### 웹로그  
아파치나 NginX, iPlanet과 같은 모든 웹 서버에 공통적으로 제공되는 기능이 웹로그이다.  
웹서버에서는 모든 요청에 대한 로그를 쌓는데, 대부분 하나의 클라이언트에서 동일한 파일을 한 번 다운로드 받으면 304 리턴 코드를 제공한다.  
그래서 다시 다운로드 받지는 않지만, 서버에는 변경되었는지 확인하는 요청을 하므로 이러한 내용도 모두 로그에 남는다.  
  
성능 튜닝을 위한 기초 법칙 중 암달의 법칙을 수식으로 표현하면,  
성능 개선율 = 1 / {(1-P) + P/S}  
P = 개선 가능한 부분의 비율  
S = 개선된 정도  
예를들어, 개선가능 부분이 100%면 P = 1, 2배의 성능 향상이 이루어졌다면 S = 2가 되어 성능 개선율은 2가 된다.   
이 법칙을 간단하게 설명한다면 1 Core에서 20시간 소요되는 작업 중 1시간은 절대 개선할 수 없다면, 20배 이상의 성능 향상은 불가능하다는 법칙이다.  
이는 곧 아무리 최적화된 시스템이라고 할지라도 생각지도 못한 부분의 성능 저하는 발생할 수 밖에 없음을 의미한다.  
  
  
### 애플리케이션에서 점검해야 할 대상들  
1. 너무 많은 패턴을 사용하지 않았는가?  
2. 데이터를 리턴할 때 TO(VO) 패턴을 사용하였는가? 아닌면 Collection 관련 클래스를 사용하였는가?  
HashMap으로 데이터를 주고 받으면, 소스를 완전히 뜯어 보지 않는 이상 개발자만 어떤 키와 값이 들어 있는지 알게 된다.  
3. 명명 규칙은 잘 지켰는가?  
그 클래스 이름을 보고 어떤 일을 하는 클래스인지 바로 인식이 가능한지를 확인해야 한다.  
4. 예외 정보를 e.printStackTrace()로만 처리하고 있지 않은가?  
서버에서 스택 정보를 취합하여야 하기 때문에 서버에 많은 부하가 발생하며, 다른 로그와 섞여 있는 스택 정보 로그를 통해서 많은 문제를 해결하기 어렵다.  
5. 무한 루프가 작동할 만한 코드는 없는가?  
'해당 구문 안에서 조건을 만족시키지 못하고 무한로프를 돌게 된다면' 이라는 가정을 할 필요가 없도록 코딩을 해야 한다.  
6. 디버그용 System.out.println()을 다 제거했는가?  
  
  
### Cache의 활용  
캐시는 날아가도 상관 없는 데이터를 처리하는데 사용하는 것이 좋으며, 예로  
1. 1분에 몇 번 로그인하는지 확인하고자 할 때  
2. 카페 등에서 최근에 쓴 글이 어떤 글인지 확인하고자 할 때  
3. CPU 사용량 등과 같이 수집되는 데이터가 10만개 중 한두개 없어져도 전혀 문제 안되는 작업을 할 때  
  
등 매우 자주 사용되면서 캐시에 없으면 DB에서 가져오면 되는 것들에 적용하면 큰 효과를 볼 수 있다.  
또한, 캐시는 다양한 언어에서 사용할 수 있는 각종 클라이언트용 API들이 존재하며, 캐시를 선택했다면 그 캐시에서 제공하는 클라이언트 API가 있는지도 확인해 봐야만 한다.  

서비스를 개발하는 개발자들의 기준으로 보는 캐시를 분류하면 로컬 캐시와 글로벌 캐시가 있다.  
로컬 캐시는 하나의 장비나 JVM 내에서 캐시 내용이 공유되는 것으로, 서로 다른 장비에 있는 데이터를 사용하기 위한 통신비용이 들지 않는 캐시이다.  
이와 다르게 글로벌 캐시는 다른 장비에 있는 캐시의 내용을 공유하여 데터 동기화가 실시간으로 이루어지기 때문에 모든 사용자가 동일한 데이터를 가질 수 있다.  
