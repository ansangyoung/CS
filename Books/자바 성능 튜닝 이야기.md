### 자바 성능 튜닝 이야기  
  
  
static은 원리를 알고 잘 사용하면 시스템의 성능을 향상시킬 수 있다.  
1. static으로 선언한 변수는 객체의 변수가 되는 것이 아니라 클래스변수가 된다.  
2. 클래스변수를 포함한 클래스의 인스턴스를 여러 개 생성하더라도, 모든 객체가 클래스 변수에 대해서는 동일한 주소의 값을 참조한다.  
-> 다른 JVM 에서는 static이라고 선언해도 다른 주소나 다른 값을 참조하지만, 하나의 JVM이나 WAS 인스턴스에서는 같은 주소에 존재하는 값을 참조한다.  
  
3. GC의 대상이 되지 않는다. 이는 곧 OutOfMemoryError 를 발생시킬 수 있으며, 이 경우 해당 인스턴스는 더이상 서비스할 수 없어서 시스템을 재시작해야 한다.  
-> 더 이상 사용 가능한 메모리가 없어지는 현상을 메모리릭이라고 하며, 원인은 메모리의 현재 상태를 파일로 남기는 HeapDump라는 파일을 통해서 확인 가능하다. JDK/bin 디렉토리에 있는 jmap이라는 파일을 사용하여 덤프를 남길 수 있으며, 남긴 덤프는 eclipse 프로젝트에서 제공하는 MAT와 같은 툴을 통해서 분석하면 된다.  
  
4. static을 잘못 사용하는 예로  다음을 기억해 두자.  
``private static boolean successFlg;`` // 응시자의 합격 여부  
수십 명이 동시에 자신의 정보를 호출한다면, 다른 사용자의 요청에 의해 다른 결과를 받게 된다.  
  
  
JSP의 경우 가장 처음에 호출되는 경우에만 시간이 소요되고, 그 이후의 시간에는 컴파일된 서블릿 클래스가 수행된다.  
JSP의 라이프 사이클은   
1. JSP URL 호출  
2. JSP 페이지 번역  
3. JSP 페이지 컴파일  
4. 클래스 로드  
5. 인스턴스 생성  
6. jspInit 메서드 호출  
7. _jspService 메서드 호출  
8. jspDestory 메서드 호출  
  
서버의 종류에 따라서 서버가 기동될 때 컴파일을 미리 수행하는 Pre-compile 옵션이 있다. 
이 옵션을 선택하면 서버에 최신 버전을 반영한 이후에 처음 호출되었을 때 응답 시간이 느린 현상을 방지할 수 있지만, 개발 시에 이 옵션을 켜 놓으면 서버를 기동할 때마다 컴파일을 수행하기 때문에 시간이 오래걸린다.  
  
JSP include에는 ``<%@ include file="관련 URL"%>``와 같이 JSP 페이지 번역 및 컴파일 단계에서 필요한 JSP를 읽어서, 메인 JSP의 자바 소스 및 클래스에 포함을 시키는 정적인 방식과  
``<jsp:include page="relativeURL"/>``와 같이 페이지가 호출될 때마다 지정된 페이지를 불러들여서 수행하는 동적인 방식이 있다.  
  
WAS의 JVM이 시작한 후의 서블릿의 라이프 사이클은  
1. Servlet 객체가 자동으로 생성되고 초기화 되거나  사용자가 해당 Servlet을 처음으로 호출했을 때 생성되고 초기화  
2. 그 다음에는 계속 '사용 가능' 상태로 대기  
3. 중간에 예외가 발생하면 '사용 불가능' 상태로 빠졌다가 다시 '사용 가능' 상태로 변환   
4. 해당 서블릿이 더 이상 필요 없을 때, '파기' 상태로 넘아간 후 JVM에서 '제거'  
  
서블릿은 JVM에 여러 객체로 생성되지 않는다.  
WAS가 시작하고 '사용 가능' 상태가 된 이상 대부분의 서블릿은 JVM에 살아 있고, 여러 스레드에서 해당 서블릿의 service() 메서드를 호출하여 공유한다.  
service() 메서드를 구현할 때는 멤버 변수나 클래스 변수를 선언하여 지속적으로 변경하는 작업은 피해야 한다.  
  