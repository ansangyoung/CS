# 시작하세요! 도커/쿠버네티스  

### 용찬호 지음  

### 2.5 도커 데몬  
#### 2.5.1 도커의 구조  
a. 도커 명령어의 위치 확인  
which docker  
-> /usr/bin/docker  
-> 참고: 리눅스의 which 명령어는, 명령어의 파일이 위치한 경로를 출력한다.  
-> 의미: 도커 명령어는 /usr/bin/docker에 위치한 파일을 통해 사용되고 있음. 즉, 컨테이너나 이미지를 다루는 도커 명령어는 /usr/bin/docker에서 실행한다.  

b. 실행 중인 도커 프로세스를 확인  
ps aux | grep docker  
-> USER  PID    %CPU  %MEM  VSZ     RSS    TT  STAT  START  TIME  COMMAND  
   root  20907  0.0   6.7   594500  68872  ?   Ssl   16:28  0:05  /usr/bin/dockerd -H fd://
-> 참고: ps aux 명령어는, 실행 중인 프로세스의 목록을 출력한다. (CPU, MEM사용률, 프로세스 상태 코드 등 확인 가능.)  
-> /usr/bin/dockerd 파일로 도커 엔진의 프로세스를 실행한다. (docker가 아닌 dockerd(도커 데몬)으로 실행하는 이유는, docker 명령어는 클라이언트이기 때문이다.)  

c. 도커의 구조  (클라이언트 + 서버)  
도커 엔진은 외부에서 API 입력을 받아 도커 엔진의 기능을 수행하는데, 도커 프로세스가 실행되어 서버로서 입력을 받을 준비가 된 상태를 "도커 데몬"이라고 한다.  
(데몬: 사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로그램. 일반적으로 프로세스로 실행된다.)  
도커 데몬은 API 입력을 받아 도커 엔진의 기능을 수행하는데, 이 API를 사용할 수 있도록 CLI를 제공하는 것이 "도커 클라이언트"이다.  
실제로 컨테이너를 생성하고 실행하며 이미지를 관리하는 주체는 "도커 서버"로, 도커 데몬 프로세스로서 동작한다.  
-> 즉, 서버로서의 도커 == 도커 데몬 이라고 인지해도 됨.  

d. 도커 데몬을 제어하는 순서  
-> 사용자가 docker로 시작하는 명령어(예를들어, docker version)를 입력하면 도커 클라이언트를 사용하는 것이며, 도커 클라이언트는 입력된 명령어를 로컬에 존재하는 도커 데몬에게 API로서 전달한다.  
-> 도커 데몬은 이 명령어를 파싱하고, 명령어에 해당하는 작업을 수행하며, 수행 결과를 도커 클라이언트에게 반환하고, 사용자에게 결과를 출력한다.  



### 2.5.2 도커 데몬 실행 (2가지 방법) 
도커 데몬은, 일반적으로 service 명령어로 시작, 정지할 수 있다.  
service docker start  
service docker stop  
우분투에서는 도커가 설치되면 자동으로 서비스로 등록되므로, 호스트가 재시작되더라도 자동으로 실행한다.  
그러나, 레드햇 계열의 운영체제는 도커를 설치해도 자동으로 실행되도록 설정되지는 않는다.  
-> 이때, 도커를 자동으로 실행하도록 설정하려면 systemctl enable docker 와 같은 명령어로 docker 서비스를 활성화할 수 있다.  

또한, 서비스를 사용하지 않고 dockerd 입력으로 직접 도커 데몬을 실행할 수 있다.(2.5.1  b.)  
그러나, 실제 운영환경에서는 도커 데몬을 직접 실행하기보다는 service, systemctl 명령어를 통해 리눅스 서비스로서 관리하는 것이 좋다.  
-> 직접 도커 데몬을 실행하면 하나의 터미널을 차지하는 포그라운드 상태로 실행되기 때문이다.  


### 2.5.3 도커 데몬 설정  
#### 2.5.3.1 도커 데몬 제어: -H  
-H 옵션은 도커 데몬의 API를 사용할 수 있는 방법을 추가한다.  
예를들어, -H에 IP 주소와 포트 번호를 입력하면 원격 API인 Docker Remote API로 도커를 제어할 수 있다.  
Remote API는 로컬에 있는 도커 데몬이 아니더라도 제어할 수 있으며, Restful API 형식을 띠고 있으므로 HTTP 요청으로 도커를 제어할 수 있다.  

예를들어, 호스트의 모든 네트워크 인터페이스 카드에 할당된 IP 주소와 2375번 포트로 도커 데몬을 제어함과 동시에, 도커 클라이언트도 사용할 수 있는 방법은 다음과 같다.  
dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375  
(도커 클라이언트는 /var/run/docker.sock에 위치한 유닉스 소켓을 통해 도커 데몬의 API를 호출한다.)  
(도커의 Remote API를 사용하는 포트는 보안이 적용돼 있지 않다면 2375번 포트를, 보안이 적용되어 있다면 2376번 포트를 사용하도록 관례상 설정한다.)  
API에 따라서 사용하는 방법이 도커 명령어와 조금씩 다른 부분도 있으므로, HTTP 도구로 직접 API 요청을 전송하기보다는, 특정 언어로 바인딩된 라이브러리를 사용하는 것이 일반적이다.  


#### 2.5.3.2 도커 데몬에 보안 적용: --tlsverify  
도커를 설치하면 기본적으로 보안 연결이 설정돼 있지 않다. 이는 도커 클라이언트, Remote API를 사용할 때 별도의 보안이 적용되지 않음을 의미한다.  
보안이 적용되어 있지 않으면 Remote API를 위해 바인딩된 IP주소와 포트 번호만 알면 도커를 제어할 수 있다.  
도커 데몬에 TLS보안을 적용하거나 도커 클라이언트와 Remote API 클라이언트가 인증되지 않으면 도커 데몬을 제어할 수 없도록 설정할 수 있다.  
TLS(Transpot Layer Security): 인터넷에서 정보를 암호화해서 송수신하는 프로토콜로 SSL에 기반한 기술이다.  


#### 2.5.3.3 도커 스토리지 드라이버 변경: --storage-driver  
도커는 특정 스토리지 백엔드 기술을 사용해 도커 컨테이너와 이미지를 저장하고 관리한다.  
일부 운영체제는 도커를 설치할 때 기본적으로 사용하도록 설정된 스토리지 드라이버가 있는데, 우분투같은 데비안 계열 운영체제는 overlay2를, 구 버전의 CentOS와 같은 운영체제는 devicemapper를 사용하는 것이 대표적인 예이다.  
이는 docker info 명령어로 확인할 수 있다.  
docker info | grep "Storage Driver"  
-> Storage Driver: overlay2  

스토리지 드라이버의 원리  
도커 스토리지 드라이버는 CoW, RoW를 지원해야 한다.  
스냅숏: 원본 파일은 읽기 전용으로 사용하되, 이 파일이 변경되면 새로운 공간을 할당  
이미지: 읽기 전용 파일로 사용하며, 각 스냅숏에 해당  
컨테이너: 이미지 위에 얇은 컨테이너 레이어를 생성함으로써 컨테이너의 고유한 공간을 생성. 스냅숏을 사용하는 변경점이다. 이전 이미지에서 변경된 사항이 저장되어 있다.  
컨테이너를 이미지로 만들면, 변경된 사항이 스냅샷으로 생성된다.  

CoW (Copy-on-Write)  
스냅숏의 파일에 쓰기 작업을 수행할 때, 스냅숏 공간에 원본 파일을 복사한 뒤, 쓰기 요청을 반영한다.  
이 과정에서 복사하기 위해 파일을 읽는 작업 한 번, 파일을 스냅숏 공간에 쓰고 변경된 사항을 쓰는 작업 한 번, 총 2번의 쓰기 작업이 일어나므로 오버헤드가 발생한다.  
Row (Redirect-on-Write)  
파일을 스냅숏 공간에 복사하는 것이 아니라, 스냅숏에 기록된 원본 파일은 스냅숏 파일로 묶은 뒤, 변경된 사항을 새로운 장소에 할당받아 덮어쓰는 형식이다.  
즉, 스냅숏 파일은 그대로 사용하되, 새로운 블록은 변경 사항으로써 사용하는 것이다.  


#### 2.5.3.4 컨테이너 저장 공간 설정  
컨테이너 내부에서 사용되는 파일시스템의 크기는 도커가 사용하고 있는 스토리지 드라이버에 따라 조금씩 다르다.  
예를들어, AUFS나 overlay2 등의 스토리지 드라이버를 사용하도록 설정되어 있다면, 컨테이너는 호스트와 저장 공간의 크기를 공유한다.  
devicemapper와 같은 드라이버를 사용하고 있다면, 기본적으로 컨테이너는 10GB의 저장 공간을 할당 받는다.  

### 2.5.4 도커 데몬 모니터링  
#### 2.5.4.1 도커 데몬 디버그 모드  
도커 데몬을 디버그모드로 실행하면, Remote API의 입출력뿐만 아니라, 로컬 도커 클라이언트에서 오가는 모든 명령어를 로그로 출력한다.  
디버그모드는 도커 데몬을 실행할 때 -D 옵션을 추가해서 사용할 수 있다.  
그러나 로그에는 원하지 않는 정보까지 너무 많이 출력되며, 도커 데몬을 포그라운드 상태로 실행해야 한다는 단점이 있다.  


#### 2.5.4.2 events, stats, system df 명령어  
events  
도커 자체가 제공하는 기능이며, 도커가 기본으로 제공하는 명령어이다.  
docker events 또는 docker system events로 입력하면, "도커 데몬에 어떤 일이 일어나고 있는지를" 실시간 스트림 로그로 보여준다.  
다음 예는 이미지에 관한 로그만 출력하도록 설정하여 이미지에 관련된 명령어만 출력할 수 있다.  
docker events --filter 'type=image'  

stats  
실행중인 모든 컨테이너의 "자원 사용량"을 스트림으로 출력한다. CPU, 메모리 제한 및 사용량, 네트워크 입출력(I/O), 블록 입출력(하드웨어 입출력) 정보를 출력한다.  
CONTAINER     ID NAME         CPU %  MEM USAGE / LIMIT     MEM %  NET I/O   BLOCK I/O        PIDS  
42974ae6b3de  k8s_jenkins_..  0.06%  663.1MiB  / 7.007GiB  9.24%  0B / 0B   129MB / 3.36MB   39  

system df  
도커에서 사용하고 있는 "이미지, 컨테이너, 로컬 볼륨의 총 개수 및 사용 중인 개수, 크기, 삭제함으로 확보 가능한 공간"을 출력한다.  
TYPE    TOTAL  ACTIVE  SIZE     RECLAIMABLE  
Images  128    21      49.99GB  41.19GB (82%)  


#### 2.5.4.3 CAdvisor  
구글이 만든 컨테이너 모니터링 도구로, 컨테이너로서 간단히 설치할 수 있고 컨테이너별 실시간 자원 사용량 및 도커 모니터링 정보 등을 시각화해서 보여준다.  
오픈소스로서 깃허브에서 소스코드로 사용할 수 있으며, 도커 허브에서 도커 이미지로도 배포되고 있다.  


### 2.5.5 Remote API 라이브러리를 이용한 도커 사용  
-H 옵션을 원격의 도커 데몬을 제어하기 위해 사용하는 것도 좋은 방법이다.  
컨테이너 애플리케이션이 수행해야 할 작업이 많거나 애플리케이션 초기화 등에 복잡한 과정이 포함되어 있다면, 도커를 제어하는 라이브러리를 사용해 이를 좀 더 쉽게 해결할 수 있다.  
즉, 도커를 제어하고 싶을 경우 일일이 Remote API에 대한 요청을 소스코드로 제작할 필요 없이, 이미 Remote API를 래핑해서 사용하기 쉽게 만들어 놓은 라이브러리를 이용할 수 있다.  


### 참고자료  
1.[파란하늘의 지식창고](https://luvstudy.tistory.com/106)  