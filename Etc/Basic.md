# Basic  
  
  
### 브라우저 동작 원리  
1. 사용자 인터페이스  
사용자가 접근할 수 있는 영역이다.  
URI를 입력할 수 있는 주소 표시줄, 이전/다음 버튼, 북마크 메뉴, 새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼 , 홈 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.  
  
2. 브라우저 엔진  
사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.  
Data Storage를 참조하며 로컬에 데이터를 쓰고 읽으면서 다양한 작업을 한다.  
  
3. 렌더링 엔진  
웹 서버로부터 응답 받은 자원을 웹 브라우저 상에 나타낸다.  
예를 들어 HTML 문서를 응답받으면 HTML과 CSS를 파싱 하여 화면에 표시한다.  
브라우저의 동작 원리를 이해하려면 렌더링 엔진의 이해가 중요하다.  
  
브라우저는 서버로부터 HTML 문서를 응답받으면 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(parsing)되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합한다.  
이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 나타낸다.  
  
4. 통신  
HTTP 요청과 같은, 서버와 통신이 가능하게 하는 네트워크 호출에 사용된다.  
  
5. UI 백엔드  
select, input 등 기본적인 위젯을 그리는 인터페이스이다.  
  
6. 자바스크립트 해석기  
자바스크립트 코드를 해석하고 실행한다.  
  
7. 자료 저장소  
Cookie, Local Storage, Indexed DB 등 브라우저 메모리를 활용하여 저장하는 영역이다.  
  
렌더링 엔진 동작 과정  
렌더링 엔진은 서버로부터 응답받은 HTML 문서를 얻는 것으로 시작한다.  
이 문서의 내용은 보통 8KB 단위로 전송된다.  
렌더링 엔진 동작 과정(참고: https://d2.naver.com/helloworld/59361)  
1. 렌더링 엔진은 HTML 문서를 파싱 하여 DOM 트리를 구축한다.  
2. 그다음 외부 CSS 파일과 함께 포함된  스타일 요소를 파싱한다.  
3. DOM 트리와 ②의 결과물을 합쳐 렌더 트리를 구축한다.  
4. 렌더 트리 각 노드에 대해 화면 상에서 배치할 곳을 결정한다.  
5. UI 백엔드에서 렌더 트리의 각 노드를 그린다.  
  
  
### http  
HTTP(HyperText Transfer Protocol, 문화어: 초본문전송규약, 하이퍼본문전송규약)는 W3 상에서 정보를 주고받을 수 있는 프로토콜이다.  
주로 HTML 문서를 주고받는 데에 쓰인다.  
주로 TCP를 사용하고 HTTP/3 부터는 UDP를 사용하며, 80번 포트를 사용한다.  
1996년 버전 1.0, 그리고 1999년 1.1이 각각 발표되었다.  
  
HTTP는 클라이언트와 서버 사이에 이루어지는 요청/응답(request/response) 프로토콜이다.  
예를 들면, 클라이언트인 웹 브라우저가 HTTP를 통하여 서버로부터 웹페이지(HTML)나 그림 정보를 요청하면,  
서버는 이 요청에 응답하여 필요한 정보를 해당 사용자에게 전달하게 된다.  
이 정보가 모니터와 같은 출력 장치를 통해 사용자에게 나타나는 것이다.  
  
HTTP를 통해 전달되는 자료는 http:로 시작하는 URL(인터넷 주소)로 조회할 수 있다.  
  
  
### URI  
URI는 특정 리소스를 식별하는 통합 자원 식별자(Uniform Resource Identifier)를 의미한다.  
웹 기술에서 사용하는 논리적 또는 물리적 리소스를 식별하는 고유한 문자열 시퀀스다.  
  
  
### URL  
URL은 흔히 웹 주소라고도 하며, 컴퓨터 네트워크 상에서 리소스가 어디 있는지 알려주기 위한 규약이다.  
URI의 서브셋이다.(URL ⊂ URI)  
  
  
### SOAP  
SOAP(Simple Object Access Protocol)은 일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다.  
SOAP은 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다.  
SOAP에는 몇가지 형태의 메시지 패턴이 있지만,  
보통의 경우 원격 프로시져 호출(Remote Procedure Call:RPC) 패턴으로,  
네트워크 노드(클라이언트)에서 다른 쪽 노드(서버)로 메시지를 요청 하고,  
서버는 메시지를 즉시 응답하게 된다.  
SOAP는 XML-RPC와 WDDX에서 envelope/header/body로 이루어진 구조와 전송(transport)과 상호 중립성(interaction neutrality)의 개념을 가져왔다.  
  
SOAP은 XML을 근간으로 헤더와 바디를 조합하는 디자인 패턴으로 설계되어 있다.  
「헤더」는 선택사항으로 반복이나 보안 및 트랜잭션을 정보로 하는 메타 정보를 가지고 있다.  
「바디」부분은 주요한 정보인 정보를 가지고 있다.  
  
  
### REST API  
REST(Representational State Transfer)는 월드 와이드 웹과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식이다.  
이 용어는 로이 필딩(Roy Fielding)의 2000년 박사학위 논문에서 소개되었다.  
필딩은 HTTP의 주요 저자 중 한 사람이다.  
이 개념은 네트워킹 문화에 널리 퍼졌다.  
  
엄격한 의미로 REST는 네트워크 아키텍처 원리의 모음이다.  
여기서 '네트워크 아키텍처 원리'란 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반을 일컫는다.  
간단한 의미로는, 웹 상의 자료를 HTTP위에서 SOAP이나 쿠키를 통한 세션 트랙킹 같은 별도의 전송 계층 없이 전송하기 위한 아주 간단한 인터페이스를 말한다.  
이 두 가지의 의미는 겹치는 부분과 충돌되는 부분이 있다.  
필딩의 REST 아키텍처 형식을 따르면 HTTP나 WWW가 아닌 아주 커다란 소프트웨어 시스템을 설계하는 것도 가능하다.  
또한, 리모트 프로시저 콜 대신에 간단한 XML과 HTTP 인터페이스를 이용해 설계하는 것도 가능하다.  
  
필딩의 REST 원리를 따르는 시스템은 종종 RESTful이란 용어로 지칭된다.  
열정적인 REST 옹호자들은 스스로를 RESTafrians 이라고 부른다.  
  
  
### REST 아키텍처에 적용되는 6가지 제한 조건  
다음 제한 조건을 준수하는 한 개별 컴포넌트는 자유롭게 구현할 수 있다.  
  
1. 인터페이스 일관성 : 일관적인 인터페이스로 분리되어야 한다.  
2. 무상태(Stateless): 각 요청 간 클라이언트의 콘텍스트가 서버에 저장되어서는 안 된다.  
3. 캐시 처리 가능(Cacheable): WWW에서와 같이 클라이언트는 응답을 캐싱할 수 있어야 한다.  
잘 관리되는 캐싱은 클라이언트-서버 간 상호작용을 부분적으로 또는 완전하게 제거하여 scalability와 성능을 향상시킨다.  
  
4. 계층화(Layered System): 클라이언트는 보통 대상 서버에 직접 연결되었는지, 또는 중간 서버를 통해 연결되었는지를 알 수 없다.  
중간 서버는 로드 밸런싱 기능이나 공유 캐시 기능을 제공함으로써 시스템 규모 확장성을 향상시키는 데 유용하다.  
  
5. Code on demand (optional): 자바 애플릿이나 자바스크립트의 제공을 통해 서버가 클라이언트가 실행시킬 수 있는 로직을 전송하여 기능을 확장시킬 수 있다.  
6. 클라이언트/서버 구조 : 아키텍처를 단순화시키고 작은 단위로 분리(decouple)함으로써 클라이언트-서버의 각 파트가 독립적으로 개선될 수 있도록 해준다.  
  
  
### REST 인터페이스의 원칙에 대한 가이드  
1. 자원의 식별  
요청 내에 기술된 개별 자원을 식별할 수 있어야 한다.  
웹 기반의 REST 시스템에서의 URI의 사용을 예로 들 수 있다.  
자원 그 자체는 클라이언트가 받는 문서와는 개념적으로 분리되어 있다.  
예를 들어, 서버는 데이터베이스 내부의 자료를 직접 전송하는 대신, 데이터베이스 레코드를 HTML, XML이나 JSON 등의 형식으로 전송한다.  
  
2. 메시지를 통한 리소스의 조작  
클라이언트가 어떤 자원을 지칭하는 메시지와 특정 메타데이터만 가지고 있다면 이것으로 서버 상의 해당 자원을 변경·삭제할 수 있는 충분한 정보를 가지고 있는 것이다.  
  
3. 자기서술적 메시지  
각 메시지는 자신을 어떻게 처리해야 하는지에 대한 충분한 정보를 포함해야 한다.  
예를 들어 MIME type과 같은 인터넷 미디어 타입을 전달한다면, 그 메시지에는 어떤 파서를 이용해야 하는지에 대한 정보도 포함해야 한다.  
미디어 타입만 가지고도, 클라이언트는 어떻게 그 내용을 처리해야할 지 알 수 있어야 한다.  
메시지를 이해하기 위해 그 내용까지 살펴봐야 한다면, 그 메시지는 자기서술적이 아니다.  
예를 들어, 단순히 "application/xml"이라는 미디어 타입은, 실제 내용을 다운로드 받지 않으면 그 메시지만 가지고는 무엇을 해야할지에 대해 충분히 알려주지 못한다.  
  
4.애플리케이션의 상태에 대한 엔진으로서 하이퍼미디어  
만약에 클라이언트가 관련된 리소스에 접근하기를 원한다면, 리턴되는 지시자에서 구별될 수 있어야 한다.  
충분한 콘텍스트 속에서의 URI를 제공해주는 하이퍼텍스트 링크의 예를 들 수 있겠다.  
  
  
### REST 의 주요한 목표  
1. 구성 요소 상호작용의 규모 확장성(scalability of component interactions)  
2. 인터페이스의 범용성 (Generality of interfaces)  
3. 구성 요소의 독립적인 배포(Independent deployment of components)  
4. 중간적 구성요소를 이용해 응답 지연 감소, 보안을 강화, 레거시 시스템을 인캡슐레이션 (Intermediary components to reduce latency, enforce security and encapsulate legacy systems)  
  
  
### curl  
curl은 오픈 소스로 개발되어 윈도우와 리눅스에 기본 설치되고 있는 웹 개발 툴로,  
http, https, ftp, sftps, smtp, telnet 등의 다양한 프로토콜과  
Proxy, Header, Cookie 등의 세부 옵션까지 쉽게 설정할 수 있다.  
이러한 장점 때문에 서버 동작을 먼저 확인하고, Client 개발 진행을 할 수 있다.  
  
  
### 페어프로그래밍  
컴퓨터 한 대에 두명의 프로그래머가 앉아 컴포넌트의 코드를 작성하는 소프트웨어 개발 접근 방법  
  
  
### 빅오표현법  
입력 값이 바뀌었을 때 알고리즘의 성능이 어떻게 바뀌는지를 알려준다.  
  
  
### 프레임워크  
어떠한 목적을 달성하기 위해 복잡하게 얽혀있는 문제를 해결하기 위한 구조.  
소프트웨어 개발에 있어 하나의 뼈대 역할.  
클래스와 라이브러리가 합쳐진 형태.  
  
ex)  
spring: 자바의 웹 프레임워크  
Django: 파이썬의 웹 프레임워크  
Ruby on Rails: 루비의 웹 프레임워크  
Codeigniter: php의 웹 프레임워크  
  
  
### 바인딩  
프로그램의 각종 변수값들이 실제 값으로 묶여 버리는 것.  
  
  
### 마운트  
어떠한 것을 Available 한 상태로 준비하는 것.  
예를 들어 소스파일을 Compile 하는 것은 운영체제가 사용할 수 있도록 Mount하는 것의 구체적인 예이다.  
  
  
### 포팅  
CPU, 운영체제, 서드 파티 라이브러리 등 실행 가능한 프로그램이 원래 설계된 바와 다른 컴퓨팅 환경에서 동작할 수 있도록 하는 과정.  
소프트웨어나 하드웨어가 다른 환경에서 사용할 수 있게 변경되는 것에도 해당한다.  
  
    
### VPC  
가상 프라이빗 클라우드  
  
  
### cron  
유닉스 계열 컴퓨터 운영 체제의 시간 기반 잡 스케줄러.  
cron은 셸 명령어들이 주어진 일정에 주기적으로 실행하도록 규정해놓은 crontab (cron table) 파일에 의해 구동된다.  
crontab 파일들은 잡 목록 및 cron 데몬에 대한 다른 명령들이 보관된 위치에 저장되어 있다.  
사용자들은 자신들만의 개개의 crontab 파일들을 가질 수 있으며,  
가끔은 /etc 또는 /etc의 하위 디렉터리에 시스템 관리자들만이 편집할 수 있는, 시스템 전반에 영향을 미치는 crontab 파일이 존재하는 경우도 있다.  
  
  
### ICU(International Components for Unicode)  
컴퓨터 소프트웨어에서 유니코드를 다루기 위한 C/C++, Java용 멀티 플랫폼 오픈 소스 라이브러리  
  
  
### IPC (InterProcess Communication) 
프로세스간 통신 방법으로 공유메모리, 세마포어, 메시지큐, 소켓, 파일 등이 있다.  
  
  
### Shared Memory  
IPC기법 중 하나이며, 여러 프로세스에서 동시에 접근할 수 있는 메모리  
하드웨어에서 공유메모리는 멀티프로세스 프로그램에서 여러 개의 CPU가 공통적으로 접근 가능한 RAM의 영역을 의미한다.  
공유메모리는 RAM에 올라가기 때문에 반드시 같은 기계에서만 사용이 가능하다.  
프로세스들이 접근할 수 있는 주소를 만들어, 직접 접근하여 변수처럼 쉽게 사용한다.  
초기에 한번만 함수를 호출하고, 그 이외에는 함수를 콜할 필요없이 변수에 접근하면 된다.  
  
  
### 메시지 큐  
짧은 메시지(1~2kb)를 주고 받는데 특화되어 있어서, 짧은 메시지에 대해서는 속도가 가장 빠르다.  
큰 메시지는 소켓이 효율적이다.  
큐를 사용하여 프로세스 간의 메시지를 전달한다.  
  
  
### MCI (Multi Channel Integration)  
기업 시스템 구조에서 다양하게 구분된 업무 채널을 효율적으로 관리하기 위한 체계  
또는 이를 실현하기 위한 솔루션, 또는 이를 구현한 프로토콜을 가리킨다.  
채널과 업무시스템 간의 복잡한 데이터 송수신, 거래제어 등의 기능과 다양한 채널(단말, 콜센터, 인터넷 등)의 연계 처리 기능을 통합하고,  
채널 및 신규업무 추가 시 프로그램의 재사용을 지원.  
  
  
### MFC(Microsoft Foundation Class Library)  
마이크로소프트에서 만든 Window API를 C++로 둘러싼 Library.  
클래스들은 윈도의 공용 컨트롤과 스마트 포인터를 사용하는 창 개체이다.  
  
  
### PKI  
공개 키 기반구조(public key infrastructure, PKI)는 디지털 인증의 생성, 관리, 배포, 사용, 저장, 파기와  
공개 키 암호화의 관리에 쓰이는 일련의 역할, 정책, 하드웨어, 소프트웨어, 절차의 총칭으로  
전자 상거래, 인터넷 뱅킹, 민감한 정보를 담은 이메일을 포함한 다양한 네트워크 활동에 있어 정보의 안전한 전송이 목적이다.  
통신 주체를 식별하거나 오가는 정보를 검증함에 있어 단순한 암호를 넘어선 엄격한 확증이 필요한 경우에 중요한 역할을 한다.  
  
암호학적으로는 공개된 키를 개인이나 집단을 대표하는 적절한 주체와 엮는 것이며 이는 인증 기관(Certificate authority, 이하 CA)에의 등록과 해당 기관에 의한 인증의 발행을 통해 성립된다.  
이 엮음은 보증의 정도에 따라 완전 자동으로 성립되기도, 사람 손을 거쳐야만 성립되기도 한다.  
    
(CA = Certification Authority)  
(RA = Registration Authority)  
(VA = Validation Authority)  
  
일반적인 기능  
1. 인증서 발급  
2. 인증서 관리  
3. 인증서 배포  
4. 인증서 사용  
5. 인증서 저장  
6. 인증서 취소  
  
  
### 메시지 암 복호화 SHA  
SHA(Secure Hash Algorithm, 안전한 해시 알고리즘) 함수들은 서로 관련된 암호학적 해시 함수들의 모음이다.  
SHA 함수군에 속하는 최초의 함수는 공식적으로 SHA라고 불리지만,  
나중에 설계된 함수들과 구별하기 위하여 SHA-0이라고도 불린다.  
2년 후 SHA-0의 변형인 SHA-1이 발표되었으며,  
그 후에 4종류의 변형, 즉 SHA-224, SHA-256, SHA-384, SHA-512가 더 발표되었다.  
이들을 통칭해서 SHA-2라고 하기도 한다.  
  
SHA-1은 SHA-0의 압축 함수에 비트 회전 연산을 하나 추가한 것으로, SHA-0과 SHA-1은 최대 264비트의 메시지로부터 160비트의 해시값을 만들어 내며,  
로널드 라이베스트가 MD4 및 MD5 해시 함수에서 사용했던 것과 비슷한 방법에 기초한다.  

SHA-1은 SHA 함수들 중 가장 많이 쓰이며, TLS, SSL, PGP, SSH, IPSec 등 많은 보안 프로토콜과 프로그램에서 사용되고 있다.  
다음은 SHA-1 해시값의 예제이다.  
```  
SHA1("The quick brown fox jumps over the lazy dog")  
  = 2fd4e1c67a2d28fced849ee1bb76e7391b93eb12  
SHA1("The quick brown fox jumps over the lazy dog.")  
  = 408d94384216f890ff7a0c3528e8bed1e0b01621  
```  
NIST는 나중에 해시값의 길이가 더 긴 네 개의 변형을 발표했으며, 이들을 통칭하여 SHA-2라 부른다.  
SHA-256, SHA-384, SHA-512는 2001년에 초안으로 처음으로 발표되었으며, 2002년에 SHA-1과 함께 정식 표준(FIPS PUB 180-2)으로 지정되었다.  
2004년 2월에 삼중 DES의 키 길이에 맞춰 해시값 길이를 조정한 SHA-224가 표준에 추가되었다.  
SHA-256과 SHA-512는 각각 32바이트 및 64바이트 워드를 사용하는 해시 함수이며, 몇몇 상수들이 다르긴 하지만 그 구조는 라운드의 수를 빼고는 완전히 같다.  
SHA-224와 SHA-384는 서로 다른 초기값을 가지고 계산한 SHA-256과 SHA-512 해시값을 최종 해시값 길이에 맞춰 잘라낸 것이다.  
  
  
### 전자서명 SEED  
한국인터넷진흥원(KISA)에서 1999년에 개발한 대칭키 암호화 알고리즘이다.  
128비트의 평문을 암호화하며, 키 크기는 128비트이다.  
암호화키가 128비트라서 AES에 가깝다는 설명이 종종 있지만 실제로는 알고리즘 구조와 기술적으로 DES가 더 가깝다.  
총 16라운드에 걸쳐 암호화를 진행하며, Addition, XOR, bit-rotation등의 연산식을 사용하여 암호화를 수행한다.  
SEED가 개발되어 배포되고 이를 통해서 대한민국 인터넷 뱅킹이 시작되었다.  
  
모질라 파이어폭스, 인터넷 익스플로러 등에 SEED 라이브러리가 깔려있고 OpenSSL에서도 SEED 128비트를 지원한다.  
256비트짜리가 만들어지게 되었으나, 국제 표준은 아니다.  
현재 128비트짜리는 국제 표준에 등재되어 있으며, 오픈 소스로 사용할 수 있는 OpenSEED도 개발되어 있다.  
2003년 KISA에선 SEED보다 더 나은 ARIA란 암호 알고리즘을 개발했고, 2004년부터 지금까지 공식적인 국가 표준 암호 알고리즘으로 사용되고 있다. 
  
이 SEED 암호화의 문제는 다른게 아니라 특정언어, 버전에 따라 암호화 및 복호화가 호환되지 않는 경우가 있으며,  
각 언어별 최소 버전이나 권장버전 등도 없다.  
암복호화는 언어, 버전에 따라 암복호화 결과가 달라서는 안됨에도 불구하고, 특정 언어나 버전에서는 제대로 암복호화가 되지 않는 단점이 있다.  
  
  
  
### 참고문헌  
1. [SHA](https://ko.wikipedia.org/wiki/SHA)  
2. [SEED](https://namu.wiki/w/SEED)  
3. [마운트(Mount)하다.](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=dbwodlf3&logNo=220980418851)  
4. [IT용어 - porting(포팅) 이란 무엇일까?](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=on21life&logNo=221179868842)  