# OS  
  
운영체제  
컴퓨터라는 하드웨어를 돌아가게 하는 엔진(규칙)으로, 프로그램과 데이터가 저장되어 있는 디스크를 운영해주는 시스템.  
  
프로그램  
컴퓨터를 실행시키기 위한 일련의 순차적으로 작성된 명령어의 모음.  
disk와 같은 secondary storage에 바이너리 형태로 저장되어 있다.  

프로세스  
실행되고 있는 프로그램의 추상화.  
하나 이상의 쓰레드를 포함한다.  

쓰레드(Thread)  
프로세스내에서 동시에 실행되는 독립적인 실행 단위를 말함.  
프로세스 내에서 실행되는 세부 작업 단위로 여러 개의 스레드가 하나의 프로세스를 이루게 되는 것이다.  
장점으로는 자원을 많이 사용하지 않고, 구현이 쉬우며, 범용성이 높고, 빠른 프로세스를 생성한다.  
단점으로는 교착상태에 빠질 수 있다.  

교착상태  
다중프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행 할 수 없는 특정시간을 기다리고 있는 상태.  


데몬  
사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로그램. 일반적으로 프로세스로 실행된다.  

포그라운드 작업  
입력한 명어러 실행이 결과가 나올 때 까지 기다리는 방식.  
다른 명령을 입력할 수 없고 기다려서 입력해야 한다.  

백그라운드 작업  
프로세스가 실행되는 동안 다른 프로세스가 실행 가능.  
실행방법은 & 기호를 추가하면 된다.  

파일  
프로세스에서 읽고 쓸 수 있는 Persistent storage.  

주소공간  
프로세스가 차지하는 메모리 공간.  

커널  
운영체제의 핵심 모듈로, 자동차로 비유하면 엔진이다. 시스템의 모든 것을 완전하게 통제하는 기능을 하며, 역할은 크게 보안, 자원 관리, 추상화로 나눌 수 있다.   

멀티 프로세서  
2개 이상의 프로세서(패터럴 시스템, 멀티코어 시스템이라고도 불림)  
하나의 프로세서가 멈추더라도 시스템이 느려지기는 하지만 멈추지 않는다.  
(시스템이 느려지지만 중지되지 않는 것을 단계별 성능저하라고 부른다.)  
멀티 프로세서의 단점은 프로그래밍단에서 멀티프로세서를 고려한 프로그래밍을 해야 한다.  
상위프로세서가 하위프로세서에게 일을 분배해서 작업하는 것을 비대칭 멀티프로세싱, 두 개 이상의 프로세서가 하나의 메모리를 공유하며 사용하는 아키텍처를 대칭 멀티프로세싱이라고 한다. 인텔 x86 등 현재 대부분의 멀티프로세스는 대칭 멀티프로세싱을 사용한다.  

멀티 프로그래밍  
메모리에 여러 개의 Job(HDD 상에: 프로그램, 메모리 상에: 프로세스, 이를 통틀어서 Job이라 칭함)을 저장해 두고 하나의 Job 실행 중 I/O 작업 등이 발생해서 유휴 시간이 생겼을 때, 다른 Job을 시작하면서 CPU의 효율성을 증가시킨다. 이로써 여러개의 작업(Job)을 메모리에 동시에 유지시킨다.  
단점으로 유저는 실행 중인 작업에 대해서는 관여할 수가 없다.  

시스템 콜  
운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스.  
프로그래밍 언어에서 지원하지 않는 기능에 대하여 운영 체제의 루틴을 호출하여 이용하는 것을 말한다.  
디스크 엑세스, 네트워크 관련 요청 등이 모두 시스템 콜에 해당한다.  
  
쉘(Shell)  
키보드로 입력한 명령어를 운영체제에 전달하여, 이 명령어를 실행하게 하는 프로그램.  
  
쉘 스크립트  
인터프리터로서, 리눅스 시스템에서 지원하는 명령어들의 집합을 묶어서 프로그램화한 것.
  
인터프리터  
프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경.
원시 코드를 기계어로 번역하는 컴파일러와 대비된다.  
코드를 한 줄씩 읽어 내려가며 실행하는 프로그램으로, 대표적으로 파이썬이 있다.  
스크립트 언어의 사실상 전부가 해당 언어의 인터프리터를 가지고 있다.  
  
컴파일러  
소스코드를 번역해서 실행파일을 만든다.  

라운드 로빈 스케줄링  
시분할 시스템을 위해 설계된 선점형 스케줄리의 하나로서,  
프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘.  
보통 시간 단위는 10 ms ~ 100 ms 정도이다.  
시간 단위동안 수행한 프로세스는 준비 큐의 끝으로 밀려나게 된다.  
문맥 전환의 오버헤드가 큰 반면, 응답시간이 짧아지는 장점이 있어 실시간 시스템에 유리하다.  


페이지 교체 알고리즘  
페이징 기법으로 메모리를 관리하는 운영체제에서, 페이지 부재가 발생하여 새로운 페이지를 할당하기 위해 현재 할당된 페이지 중 어느 것과 교체할지를 결정하는 방법.  

fifo  
페이지가 주기억장치에 적재된 시간을 기준으로 교체될 페이지를 선정하는 기법.  
단점: 중요한 페이지가 오래 있었다는 이유만으로 교체되는 불합리.  
가장 오래 있었던 페이지는 앞으로 계속 사용될 가능성이 있음.  

lfu  
가장 적은 횟수를 참조하는 페이지를 교체  
단점: 참조될 가능성이 많음에도 불구하고 횟수에 의한 방법이므로,  
최근에 사용된 프로그램을 교체시킬 가능성이 있고  
해당 횟수를 증가시키므로 오버헤드를 발생시킨다.  

Least Recently Used Algorithm  
가장 오랫동안 참조되지 않은 페이지를 교체하는 방법  
단점: 프로세스가 주기억장치에 접근할 때마다 참조된 페이지에 대한 시간을 기록해야 함.  
큰 오버헤드가 발생  

### 참고자료  
1. [OS #1. 운영체제 구조 (OS Structure)](https://devowen.com/215?category=715657)  
